This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  components/
    three/
      Cube.jsx
      GameBoard.jsx
      GameScene.jsx
      GridHelper.jsx
      Ground.jsx
      Lighting.jsx
      MagneticFieldVisualizer.jsx
      Player.jsx
      Scene.jsx
      SpaceSelector.jsx
      SpaceSelector.module.css
    ui/
      GameControls.jsx
      GameUI.jsx
      GameUI.module.css
      LogDisplay.jsx
      LogDisplay.module.css
      PlayerInfo.jsx
      PlayerInfo.module.css
      PowerCard.jsx
      PowerCardDeck.jsx
      PowerCardDeck.module.css
      PowerCards.jsx
      PowerCards.module.css
      TurnControls.jsx
      TurnControls.module.css
    GameBoard.tsx
  config/
    featureFlags.js
    GameConfig.ts
  constants/
    GameConstants.ts
  context/
    GameContext.jsx
  game/
    ActionManager.js
    gameLogic.js
  hooks/
    useGameStateMachine.ts
  services/
    highlight/
      BuildHighlighter.ts
      MovementHighlighter.ts
    logger/
      GameLogger.ts
    stateMachine/
      states/
        GameOverState.ts
        GameState.ts
        PlayingState.ts
        SetupState.ts
      GameStateMachine.ts
    strategies/
      ActionStrategy.ts
      ActionStrategyContext.ts
      BuildStrategy.ts
      MoveStrategy.ts
    utils/
      HeightCalculator.ts
    validators/
      BuildPositionCalculator.ts
      BuildValidator.ts
      MovementValidator.ts
    ActionHandler.ts
    ActionManager.ts
    BoardStateManager.ts
    gameLogic.ts
    GameManager.ts
    GameStateManager.ts
    notifications.js
    physics.js
  store/
    middleware/
      actionValidation.js
    reducers/
      gameReducer.js
    gameReducer.js
    gameSlice.js
    index.js
  utils/
    Singleton.js
    UniversalLogger.ts
  App.jsx
  App.module.css
  index.css
  index.jsx
  main.jsx

================================================================
Files
================================================================

================
File: src/components/three/Cube.jsx
================
import React, { useEffect, useRef, forwardRef } from 'react'
import { useFrame } from '@react-three/fiber'
import { Box } from '@react-three/drei'
import { RigidBody } from '@react-three/rapier'
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();

const Cube = forwardRef(({ position, color = '#ffffff', id }, ref) => {
  // Adjust y position to raise the cube by half its height
  const adjustedPosition = Array.isArray(position) 
    ? [position[0], position[1] + 0.5, position[2]]
    : position

  // Prepare userData object
  const cubeUserData = { type: 'cube', id: id };

  // Log userData directly from the mesh ref when it's available
  useEffect(() => {
    if (ref?.current) { // Check forwarded ref
      // The ref might point to the RigidBody, need to find the mesh
      // Let's assume the Box is the first child for now, this might need adjustment
      const mesh = ref.current.children?.[0];
      if (mesh) {
          console.log(`[Cube ${id} /three] Mesh ref userData:`, mesh.userData);
      }
    }
  }, [id, ref]);

  // NOTE: We likely need to get the mesh ref separately if the forwarded ref is for RigidBody
  const meshRef = useRef();
  useEffect(() => {
    if (meshRef.current) {
      console.log(`[Cube ${id} /three] DIRECT Mesh ref userData:`, meshRef.current.userData);
    }
  }, [id]);

  return (
    <RigidBody
      ref={ref}
      type="fixed"
      position={adjustedPosition}
      colliders="cuboid"
      onCollisionEnter={() => {
        logger.info('Cube collision detected')
      }}
      onCollisionExit={() => {
        logger.info('Cube collision ended')
      }}
    >
      <Box
        ref={meshRef}
        args={[1, 1, 1]}
        castShadow
        receiveShadow
        onClick={() => {}}
        onPointerEnter={() => {}}
        onPointerLeave={() => {}}
        userData={cubeUserData}
      >
        <meshStandardMaterial
          color="#ffffff"
          metalness={0.2}
          roughness={0.1}
          transparent={true}
          opacity={0.6}
        />
      </Box>
    </RigidBody>
  )
})

Cube.displayName = 'Cube'

export default React.memo(Cube)

================
File: src/components/three/GameBoard.jsx
================
import React, { useEffect } from 'react'
import { useSelector } from 'react-redux'
import { RigidBody } from '@react-three/rapier'
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
// import { MagneticPhysics } from '../../services/physics' // Removed unused import
import Cube from './Cube'
import Player from './Player'
import Ground from './Ground'

function GameBoard() {
  const game = useSelector(state => state.game)
  const players = game?.players || []
  const cubes = game?.cubes || {}

  // Removed useEffect block that used MagneticPhysics
  // useEffect(() => {
  //   logger.info('Game board initialized')
  //   const physics = MagneticPhysics.getInstance()
  //   physics.init()
  //   
  //   return () => {
  //     logger.info('Game board cleanup')
  //     physics.dispose()
  //   }
  // }, [])

  useEffect(() => {
    if (players.length > 0) {
      logger.info('Player state updated')
    }
  }, [players])

  useEffect(() => {
    if (Object.keys(cubes).length > 0) {
      logger.info('Cube state updated')
    }
  }, [cubes])

  return (
    <group>
      <Ground />
      
      {players.map(player => (
        <Player key={player.id} {...player} />
      ))}

      {Object.values(cubes).map(cube => (
        <Cube 
          key={cube.id}
          id={cube.id}
          position={cube.position}
          color={cube.owner ? players.find(p => p.id === cube.owner)?.color : '#ffffff'}
        />
      ))}
    </group>
  )
}

export default React.memo(GameBoard)

================
File: src/components/three/GameScene.jsx
================
import React from 'react'
import { useGame } from '../../context/GameContext'
import GridHelper from './GridHelper'
import MagneticFieldVisualizer from './MagneticFieldVisualizer'
import SpaceSelector from './SpaceSelector'
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();

const GameScene = () => {
  const { cubes, currentPlayer } = useGame()

  return (
    <>
      <GridHelper />
      <MagneticFieldVisualizer />
      <SpaceSelector />

      {/* Render cubes */}
      {Object.entries(cubes).map(([id, cube]) => (
        <mesh
          key={id}
          position={cube.position}
          userData={{
            type: 'cube',
            id,
            owner: cube.owner
          }}
        >
          <boxGeometry args={[1, 1, 1]} />
          <meshStandardMaterial
            color={cube.owner === currentPlayer.id ? '#00ff00' : '#ff0000'}
            metalness={0.5}
            roughness={0.5}
          />
        </mesh>
      ))}

      {/* Render players */}
      {currentPlayer && (
        <mesh position={currentPlayer.position}>
          <sphereGeometry args={[0.5, 32, 32]} />
          <meshStandardMaterial color="#0000ff" />
        </mesh>
      )}
    </>
  )
}

export default GameScene

================
File: src/components/three/GridHelper.jsx
================
import React from 'react'
import { Grid } from '@react-three/drei'

function GridHelper() {
  return (
    <Grid
      args={[10, 10]}
      position={[0, 0, 0]}
    />
  )
}

export default GridHelper

================
File: src/components/three/Ground.jsx
================
import React, { useRef, useEffect } from 'react'
import { RigidBody } from '@react-three/rapier'

const Ground = () => {
  console.log('[Ground /three] Rendering');
  const meshRef = useRef();

  useEffect(() => {
    if (meshRef.current) {
      console.log(`[Ground /three] DIRECT Mesh ref userData:`, meshRef.current.userData);
    }
  }, []);

  return (
    <RigidBody type="fixed" position={[0, -0.5, 0]}>
      <mesh
        ref={meshRef}
        rotation={[-Math.PI / 2, 0, 0]}
        receiveShadow
        userData={{ type: 'ground' }}
      >
        <planeGeometry args={[20, 20]} />
        <meshStandardMaterial
          color="#1a1a1a"
          roughness={0.8}
          metalness={0.2}
          emissive="#000000"
          emissiveIntensity={0.1}
        />
      </mesh>
    </RigidBody>
  )
}

export default Ground

================
File: src/components/three/Lighting.jsx
================
import React from 'react'
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();

const Lighting = () => {
  const directionalLightRef = React.useRef()
  
  logger.debug('Rendering Lighting')

  return (
    <>
      <ambientLight intensity={0.4} />
      
      <directionalLight
        ref={directionalLightRef}
        position={[10, 10, 5]}
        intensity={0.8}
        castShadow
        shadow-mapSize={[2048, 2048]}
        shadow-camera-left={-10}
        shadow-camera-right={10}
        shadow-camera-top={10}
        shadow-camera-bottom={-10}
        shadow-camera-near={0.1}
        shadow-camera-far={50}
      />
      
      <pointLight 
        position={[0, 10, 0]} 
        intensity={0.5}
        castShadow
        shadow-mapSize={[1024, 1024]}
      />
      
      <hemisphereLight
        skyColor="#ffffff"
        groundColor="#000000"
        intensity={0.3}
      />
    </>
  )
}

export default React.memo(Lighting)

================
File: src/components/three/MagneticFieldVisualizer.jsx
================
import React, { useMemo } from 'react'
import * as THREE from 'three'
import { useFrame } from '@react-three/fiber'

const getLOD = (distance) => {
  // Use THREE.MathUtils for clamping
  const normalizedDistance = THREE.MathUtils.clamp(distance, 5, 20)
  return Math.floor(THREE.MathUtils.mapLinear(normalizedDistance, 5, 20, 20, 5))
}

const MagneticFieldVisualizer = ({ position, strength = 1, color }) => {
  const fieldGeometry = useMemo(() => {
    const geometry = new THREE.SphereGeometry(1, 32, 32)
    return geometry
  }, [])

  const fieldMaterial = useMemo(() => {
    return new THREE.MeshBasicMaterial({
      color: color || '#ffffff',
      transparent: true,
      opacity: 0.2,
      wireframe: true
    })
  }, [color])

  // Create field lines
  const fieldLines = useMemo(() => {
    const lines = []
    const lod = getLOD(10) // Default distance for initial LOD
    
    for (let i = 0; i < lod; i++) {
      const angle = (i / lod) * Math.PI * 2
      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(
          Math.cos(angle) * strength,
          Math.sin(angle) * strength,
          0
        )
      ])
      
      const points = curve.getPoints(50)
      const geometry = new THREE.BufferGeometry().setFromPoints(points)
      lines.push(geometry)
    }
    
    return lines
  }, [strength])

  useFrame((state) => {
    // Add any animation updates here if needed
  })

  return (
    <group position={position}>
      <mesh geometry={fieldGeometry} material={fieldMaterial}>
        {fieldLines.map((geometry, index) => (
          <line key={index} geometry={geometry}>
            <lineBasicMaterial
              attach="material"
              color={color || '#ffffff'}
              opacity={0.3}
              transparent
              linewidth={1}
            />
          </line>
        ))}
      </mesh>
    </group>
  )
}

export default MagneticFieldVisualizer

================
File: src/components/three/Player.jsx
================
import React, { useEffect, useRef, forwardRef } from 'react'
import { useSelector } from 'react-redux'
import { Text } from '@react-three/drei'
import { RigidBody } from '@react-three/rapier'
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three' 
import { useFeature } from '../../config/featureFlags'

const Player = forwardRef(({ id, position, color }, ref) => {
  const currentPlayer = useSelector(state => state.game?.currentPlayer)
  const isCurrentPlayer = currentPlayer?.id === id
  const particlesRef = useRef()
  const particlesEnabled = useFeature('PARTICLE_EFFECTS')
  const meshRef = useRef();

  // Define consistent sizes for all meshes
  const playerSize = 0.4
  const fieldSize = playerSize * 1.5
  const wireframeSize = fieldSize
  const labelHeight = fieldSize * 1.2

  // Ensure position is an array and has valid numbers
  const [x, y, z] = Array.isArray(position) ? position : [0, 0, 0]
  
  // Adjust y position to raise the player by half its height
  const adjustedPosition = [x, y + 0.5, z]

  // Only create particles if the flag is enabled
  const particles = isCurrentPlayer && particlesEnabled ? Array.from({ length: 30 }, () => ({
    position: new THREE.Vector3(
      (Math.random() - 0.5) * 2,
      (Math.random() - 0.5) * 2,
      (Math.random() - 0.5) * 2
    ),
    velocity: new THREE.Vector3(
      (Math.random() - 0.5) * 0.02,
      (Math.random() - 0.5) * 0.02,
      (Math.random() - 0.5) * 0.02
    ),
    scale: Math.random() * 0.1 + 0.05,
    lifetime: Math.random() * 2 + 1
  })) : []

  // Prepare userData object
  const playerUserData = { type: 'player', id: id };

  // Log userData directly from the mesh ref when it's available
  useEffect(() => {
    if (meshRef.current) {
      logger.info(` ${id} DIRECT Mesh ref userData:`, meshRef.current.userData);
    }
  }, [id]);

  useEffect(() => {
    return () => {
      // Cleanup if needed
    }
  }, [])

  useFrame((state, delta) => {
    if (isCurrentPlayer && particlesEnabled && particlesRef.current) {
      particlesRef.current.children.forEach((particle, i) => {
        const data = particles[i]
        
        // Update position based on velocity
        particle.position.add(data.velocity)
        
        // Add some random movement
        data.velocity.x += (Math.random() - 0.5) * 0.001
        data.velocity.y += (Math.random() - 0.5) * 0.001
        data.velocity.z += (Math.random() - 0.5) * 0.001
        
        // Dampen velocity for more natural movement
        data.velocity.multiplyScalar(0.99)
        
        // Keep particles within bounds of the player
        const maxDistance = 1.5
        if (particle.position.length() > maxDistance) {
          particle.position.normalize().multiplyScalar(maxDistance)
          // Bounce back towards player
          data.velocity.multiplyScalar(-0.5)
        }
        
        // Fade opacity based on distance from center
        const distance = particle.position.length()
        const opacity = 1 - (distance / maxDistance)
        particle.material.opacity = opacity * 0.6
      })
    }
  })

  return (
    <RigidBody
      ref={ref}
      type="kinematicPosition"
      position={adjustedPosition}
      onCollisionEnter={() => {
        logger.info('Player collision detected')
      }}
      onCollisionExit={() => {
        logger.info('Player collision ended')
      }}
    >
      <mesh
        ref={meshRef}
        castShadow
        receiveShadow
        onPointerEnter={() => {}}
        onPointerLeave={() => {}}
        onClick={() => {}}
        userData={playerUserData}
      >
        <sphereGeometry args={[0.5, 32, 32]} />
        <meshStandardMaterial
          color={color}
          metalness={0.8}
          roughness={0.2}
        />
      </mesh>

      {/* Conditionally render particle group */}
      {isCurrentPlayer && particlesEnabled && (
        <group ref={particlesRef}>
          {particles.map((particle, i) => (
            <mesh key={i} position={particle.position.toArray()}>
              <sphereGeometry args={[particle.scale, 8, 8]} />
              <meshBasicMaterial 
                color={color}
                transparent
                opacity={0.6}
                blending={THREE.AdditiveBlending}
                depthWrite={false}
              />
            </mesh>
          ))}
        </group>
      )}
    </RigidBody>
  )
})

// Add display name for React DevTools
Player.displayName = 'Player'

export default Player

================
File: src/components/three/Scene.jsx
================
import React, { useEffect } from 'react'
import { Physics } from '@react-three/rapier'
import { 
  Stars,
  Environment,
  OrbitControls
} from '@react-three/drei'
import { useThree } from '@react-three/fiber'
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
import GridHelper from './GridHelper'
import Lighting from './Lighting'
import GameBoard from './GameBoard'
import SpaceSelector from './SpaceSelector'
import { ActionManager } from '../../services/ActionManager'

function Scene() {
  const { scene } = useThree()

  useEffect(() => {
    logger.info('Scene initialized')
    
    // Set the scene in ActionManager
    const actionManager = ActionManager.getInstance()
    actionManager.setScene(scene)
    logger.info('Scene set in ActionManager')

    return () => {
      logger.info('Scene cleanup')
      // Clear the scene from ActionManager on cleanup
      actionManager.setScene(null)
    }
  }, [scene])

  return (
    <>
      <OrbitControls
        enableDamping
        dampingFactor={0.05}
        minDistance={5}
        maxDistance={20}
        maxPolarAngle={Math.PI / 2}
      />
      <Stars 
        radius={100} 
        depth={50} 
        count={5000} 
        factor={4} 
        saturation={0} 
        fade 
        speed={1}
      />
      <Physics
        gravity={[0, -9.81, 0]}
        debug={false}
        onWorkerCreated={() => {
          logger.info('Physics initialized')
        }}
        onWorkerDestroyed={() => {
          logger.info('Physics cleanup')
        }}
      >
        <Lighting />
        <GridHelper />
        <GameBoard />
        <SpaceSelector />
      </Physics>
    </>
  )
}

export default Scene

================
File: src/components/three/SpaceSelector.jsx
================
import React, { useRef, useState, useEffect } from 'react'
import { useThree } from '@react-three/fiber'
import { useSelector } from 'react-redux'
import * as THREE from 'three'
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
import styles from './SpaceSelector.module.css'
import { ActionManager } from '../../services/ActionManager'
import { GameLogic } from '../../services/GameLogic'

const SpaceSelector = () => {
  const { camera, scene, gl } = useThree()
  const [hoveredPosition, setHoveredPosition] = useState(null)
  const raycaster = new THREE.Raycaster()
  const mouse = new THREE.Vector2()
  const actionManager = ActionManager.getInstance()
  const gameLogic = GameLogic.getInstance()
  const currentPlayerId = useSelector(state => state.game?.currentPlayer?.id)
  const gamePhase = useSelector(state => state.game?.gameState)

  // Recalculate valid positions when action type changes
  useEffect(() => {
    if (!currentPlayerId || gamePhase !== 'playing') return;

    const currentAction = actionManager.getCurrentAction();
    if (!currentAction) return;

    let validPositions = [];
    switch (currentAction.type) {
      case 'move':
        validPositions = gameLogic.getValidMovePositions(currentPlayerId);
        break;
      case 'build':
        const player = gameLogic.players.get(currentPlayerId);
        if (player) {
          // Convert player position to Position type
          const playerPosition = {
            x: player.position[0],
            y: player.position[1],
            z: player.position[2]
          };
          // Get valid build positions from the validator
          validPositions = gameLogic.buildValidator.getValidBuildPositions(playerPosition);
        }
        break;
      default:
        return;
    }

    // Update action manager with new valid positions
    actionManager.updateValidPositions(validPositions);
    
    logger.info('Recalculated valid positions', {
      actionType: currentAction.type,
      count: validPositions.length
    });
  }, [currentPlayerId, gamePhase, actionManager.getCurrentAction()?.type, gameLogic.boardState]);

  const getGridPosition = (intersection) => {
    const position = intersection.point
    // Calculate center of the grid cell for x/z
    // Keep y calculation based on height
    const yOffset = -0.01; 
    return {
      x: Math.floor(position.x) + 0.5,
      y: Math.ceil(position.y + yOffset),
      z: Math.floor(position.z) + 0.5
    }
  }

  const onPointerMove = (event) => {
    const rect = gl.domElement.getBoundingClientRect()
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1
  }

  const onPointerDown = (event) => {
    const rect = gl.domElement.getBoundingClientRect()
    const clickMouse = new THREE.Vector2()
    clickMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
    clickMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1

    camera.updateMatrixWorld();

    raycaster.setFromCamera(clickMouse, camera)
    const intersects = raycaster.intersectObjects(scene.children, true)

    // --- Start Debug Logging --- 
    console.log(`[SpaceSelector] Raycaster hit ${intersects.length} objects`);
    intersects.forEach((intersect, index) => {
      const obj = intersect.object;
      console.log(`  [Intersection ${index}]`, {
        name: obj.name || 'Unnamed',
        type: obj.type,
        uuid: obj.uuid,
        userData: obj.userData, // Check userData on each hit object
        parentType: obj.parent?.type,
        parentUUID: obj.parent?.uuid,
        distance: intersect.distance
      });
    });
    // --- End Debug Logging --- 

    const validIntersects = intersects.filter(intersect => {
        const obj = intersect.object;
        const isHighlight = !obj.userData?.type;
        return obj.material && obj.material.visible !== false && 
               obj.name !== "Click catcher plane" &&
               obj.type !== 'GridHelper' &&
               !obj.type.includes('Light')
    });

    if (validIntersects.length > 0) {
      const intersection = validIntersects[0];
      const clickedObject = intersection.object;
      const intersectionPoint = intersection.point;
      const clickedGridPos = getGridPosition(intersection);

      // Log the *first valid* hit object details (as before)
      console.log('[SpaceSelector] First Valid Clicked Object Raw:', clickedObject);
      
      // Log specific details again, including explicit parent info
      logger.info('Object clicked', {
        objectName: clickedObject.name || 'Unnamed',
        objectType: clickedObject.type, 
        objectID: clickedObject.uuid, 
        parentName: clickedObject.parent?.name || 'N/A',
        parentType: clickedObject.parent?.type || 'N/A',
        parentID: clickedObject.parent?.uuid || 'N/A',
        userData: clickedObject.userData, 
        position: clickedObject.position.toArray(),
        worldPosition: clickedObject.getWorldPosition(new THREE.Vector3()).toArray(), 
        distance: intersection.distance, 
        intersectionPoint: intersectionPoint.toArray(),
        gridPosition: clickedGridPos
      });

      // --- Action Validation Logic ---
      if (clickedGridPos) {
        const currentAction = actionManager.getCurrentAction();
        const validPositions = currentAction?.validPositions || [];

        const isClickValidActionTarget = currentAction && validPositions.some(
          pos => pos.x === clickedGridPos.x && 
                 pos.y === clickedGridPos.y && 
                 pos.z === clickedGridPos.z
        );

        if (isClickValidActionTarget) {
          logger.info(`Valid target clicked for action: ${currentAction.type}`, { 
            action: currentAction.type, 
            position: clickedGridPos 
          });

          // --- Perform Action --- 
          if (gamePhase !== 'playing') {
            logger.warn(`Cannot perform action '${currentAction.type}': Game phase is '${gamePhase}', not 'playing'.`);
            // Optionally provide user feedback here
            actionManager.endCurrentAction(); // Clear highlights and reset action state
            return; // Exit early
          }

          let actionSuccess = false;
          switch (currentAction.type) {
            case 'build':
              if (currentPlayerId) {
                actionSuccess = gameLogic.build(currentPlayerId, clickedGridPos);
              } else {
                logger.error('[SpaceSelector] Cannot perform build: currentPlayerId is missing.');
              }
              break;
            case 'move':
              if (currentPlayerId) {
                actionSuccess = gameLogic.move(currentPlayerId, clickedGridPos);
              } else {
                logger.error('[SpaceSelector] Cannot perform move: currentPlayerId is missing.');
              }
              break;
            default:
              logger.warn(`[SpaceSelector] Click validation passed, but no handler for action type: ${currentAction.type}`);
          }

          if (actionSuccess) {
            logger.info(`Action '${currentAction.type}' performed successfully.`);
            // TODO: Ideally, ActionManager should handle cleanup after success.
            // For now, explicitly clear highlights.
            actionManager.clearHighlights(scene); 
            actionManager.endCurrentAction(); // Assuming this method exists to reset action state
          } else {
            logger.error(`Action '${currentAction.type}' failed.`);
            // Optionally clear highlights even on failure, or let the user retry?
             actionManager.clearHighlights(scene);
             actionManager.endCurrentAction(); // Reset action state on failure too?
          }
          // --- End Perform Action ---

        } else {
            logger.info('Clicked on a grid position, but it is not a valid target for the current action (if any).', {
                clickedPosition: clickedGridPos,
                currentActionType: currentAction?.type || 'None'
            });
        }
      }
      // --- End Action Validation Logic ---

    } else {
      logger.info('Empty space or non-interactive object clicked');
    }
  }

  return (
    <group
      onPointerMove={onPointerMove}
      onPointerDown={onPointerDown}
    >
      {/* Invisible plane to catch events - ensures clicks are registered even in empty space */}
      <mesh position={[0, -0.5, 0]} rotation={[-Math.PI / 2, 0, 0]} name="Click catcher plane">
        <planeGeometry args={[100, 100]} />
        <meshBasicMaterial visible={false} side={THREE.DoubleSide} />
      </mesh>
    </group>
  )
}

export default SpaceSelector

================
File: src/components/three/SpaceSelector.module.css
================
.selector {
  position: absolute;
  pointer-events: none;
  z-index: 1000;
}

================
File: src/components/ui/GameControls.jsx
================
import React from 'react'
import { useDispatch } from 'react-redux'
import { setSelectedAction, build, move, roll, endTurn } from '../../store/gameSlice'
import { useGame } from '../../context/GameContext'
import PowerCardDeck from './PowerCardDeck'
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();

const GameControls = () => {
  const { 
    currentPlayer, 
    turnPhase, 
    selectedPowerCard, 
    dispatch, 
    gameLogic: game,
    stateMachine: { playing, currentState }
  } = useGame()

  const handleBuild = () => {
    dispatch(setSelectedAction('build'))
    // In a real implementation, we would show a grid or 3D space selector
    // For now, we'll just build at a random position
    const position = [
      Math.floor(Math.random() * 5),
      Math.floor(Math.random() * 3),
      Math.floor(Math.random() * 5)
    ]
    
    if (game.build(position)) {
      dispatch(build(position))
      // Update state machine
      playing.makeMove({
        playerId: currentPlayer.id,
        action: 'build',
        position: { x: position[0], y: position[1], z: position[2] }
      })
    }
  }

  const handleMove = () => {
    dispatch(setSelectedAction('move'))
    // In a real implementation, we would show valid move positions
    // For now, we'll just move to a random adjacent position
    const currentPos = game.getGameState().players.find(p => p.id === currentPlayer).position
    const position = [
      currentPos[0] + (Math.random() > 0.5 ? 1 : -1),
      currentPos[1],
      currentPos[2] + (Math.random() > 0.5 ? 1 : -1)
    ]
    
    if (game.move(currentPlayer, position)) {
      dispatch(move({ playerId: currentPlayer, position }))
      // Update state machine
      playing.makeMove({
        playerId: currentPlayer.id,
        action: 'move',
        position: { x: position[0], y: position[1], z: position[2] }
      })
    }
  }

  const handleRoll = () => {
    if (!currentPlayer) return
    logger.info('Rolling dice', { playerId: currentPlayer.id })
    const roll = Math.floor(Math.random() * 6) + 1
    dispatch({ type: 'game/roll', payload: roll })
    // Update state machine
    playing.makeMove({
      playerId: currentPlayer.id,
      action: 'roll',
      value: roll
    })
  }

  const handleEndTurn = () => {
    if (!currentPlayer) return
    logger.info('Ending turn', { playerId: currentPlayer.id })
    dispatch({ type: 'game/endTurn' })
    // Update state machine
    playing.makeMove({
      playerId: currentPlayer.id,
      action: 'endTurn'
    })
  }

  if (!currentPlayer || currentState === 'setup') {
    return (
      <div className="game-controls">
        <div className="player-info">
          <h2>Setting up game...</h2>
        </div>
      </div>
    )
  }

  if (currentState === 'gameOver') {
    return (
      <div className="game-controls">
        <div className="player-info">
          <h2>Game Over!</h2>
        </div>
      </div>
    )
  }

  return (
    <div className="game-controls">
      <div className="player-info">
        <h2>Player {currentPlayer.id}</h2>
        <p>Phase: {turnPhase}</p>
        {selectedPowerCard && (
          <p className="power-card-selected">
            Power Card Selected - Click on a cube to use it
          </p>
        )}
      </div>

      <div className="action-buttons">
        {turnPhase === 'start' && (
          <button
            onClick={handleRoll}
            className="action-button roll"
          >
            Roll Dice
          </button>
        )}

        {turnPhase === 'end' && (
          <button
            onClick={handleEndTurn}
            className="action-button end-turn"
          >
            End Turn
          </button>
        )}
      </div>

      <PowerCardDeck />

      <style jsx>{`
        .game-controls {
          display: flex;
          flex-direction: column;
          gap: 16px;
          padding: 16px;
        }

        .player-info {
          text-align: center;
          margin-bottom: 8px;
        }

        .player-info h2 {
          margin: 0;
          color: #fff;
          font-size: 1.2em;
        }

        .player-info p {
          margin: 4px 0 0;
          color: #ccc;
          font-size: 0.9em;
        }

        .power-card-selected {
          color: #00ff00;
          font-weight: bold;
          margin-top: 8px;
          padding: 4px 8px;
          background: rgba(0, 255, 0, 0.1);
          border-radius: 4px;
        }

        .action-buttons {
          display: flex;
          gap: 8px;
          justify-content: center;
        }

        .action-button {
          padding: 8px 16px;
          border: none;
          border-radius: 4px;
          font-size: 1em;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        .action-button:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .action-button.roll {
          background-color: #4CAF50;
          color: white;
        }

        .action-button.end-turn {
          background-color: #f44336;
          color: white;
        }

        .action-button:disabled {
          opacity: 0.5;
          cursor: not-allowed;
          transform: none;
          box-shadow: none;
        }
      `}</style>
    </div>
  )
}

export default GameControls

================
File: src/components/ui/GameUI.jsx
================
import React from 'react'
import PlayerInfo from './PlayerInfo'
import PowerCards from './PowerCards'
import TurnControls from './TurnControls'
import LogDisplay from './LogDisplay'
import styles from './GameUI.module.css'
import { useGame } from '../../context/GameContext'

const GameUI = () => {
  const { game, stateMachine } = useGame()
  const { currentState } = stateMachine

  return (
    <div className={styles.gameUI}>
      {/* Top left - Player info */}
      <div className={styles.playerInfoContainer}>
        <PlayerInfo />
      </div>

      {/* Top right - Power cards */}
      <div className={styles.powerCardsContainer}>
        <PowerCards />
      </div>

      {/* Bottom - Game controls */}
      <div className={styles.controlsContainer}>
        <TurnControls />
      </div>

      {/* Bottom right - Game log */}
      <div className={styles.logContainer}>
        <LogDisplay />
      </div>
    </div>
  )
}

export default GameUI

================
File: src/components/ui/GameUI.module.css
================
.gameUI {
  position: fixed;
  inset: 0;
  z-index: 1000;
  color: white;
  pointer-events: none;
}

.playerInfoContainer {
  position: absolute;
  top: 20px;
  left: 20px;
  pointer-events: auto;
  background: rgba(0, 0, 0, 0.7);
  padding: 16px;
  border-radius: 8px;
  backdrop-filter: blur(5px);
}

.powerCardsContainer {
  position: absolute;
  top: 20px;
  right: 20px;
  pointer-events: auto;
  display: flex;
  gap: 10px;
  background: rgba(0, 0, 0, 0.7);
  padding: 16px;
  border-radius: 8px;
  backdrop-filter: blur(5px);
}

.controlsContainer {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  pointer-events: auto;
  display: flex;
  gap: 10px;
  min-width: 400px;
  max-width: 800px;
  background: rgba(0, 0, 0, 0.7);
  padding: 16px;
  border-radius: 8px;
  backdrop-filter: blur(5px);
}

.logContainer {
  position: absolute;
  bottom: 20px;
  right: 20px;
  pointer-events: auto;
  max-width: 300px;
  max-height: 200px;
  overflow-y: auto;
  background: rgba(0, 0, 0, 0.7);
  padding: 10px;
  border-radius: 8px;
  backdrop-filter: blur(5px);
}

/* Add any additional styles for game status info here */

================
File: src/components/ui/LogDisplay.jsx
================
import React from 'react'
import { useSelector } from 'react-redux'
import styles from './LogDisplay.module.css'

const LogDisplay = () => {
  const logs = useSelector(state => state.game.logs)

  return (
    <div className={styles.logDisplay}>
      <h3>Game Log</h3>
      <div className={styles.logList}>
        {logs.map((log, index) => (
          <div key={index} className={styles.logEntry}>
            {log}
          </div>
        ))}
      </div>
    </div>
  )
}

export default LogDisplay

================
File: src/components/ui/LogDisplay.module.css
================
.logDisplay {
  background: rgba(0, 0, 0, 0.8);
  border-radius: 8px;
  padding: 12px;
  width: 300px;
}

.logDisplay h3 {
  margin: 0 0 8px 0;
  font-size: 1em;
  opacity: 0.8;
}

.logList {
  max-height: 200px;
  overflow-y: auto;
}

.logEntry {
  padding: 4px 8px;
  font-size: 0.9em;
  border-radius: 4px;
  margin-bottom: 4px;
  background: rgba(255, 255, 255, 0.1);
}

/* Scrollbar styling */
.logList::-webkit-scrollbar {
  width: 6px;
}

.logList::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
}

.logList::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 3px;
}

.logList::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

.logTimestamp {
  color: #888;
  margin-right: 8px;
}

.logLevel {
  font-weight: bold;
  margin-right: 8px;
  padding: 2px 4px;
  border-radius: 2px;
}

.logDebug {
  color: #888;
}

.logInfo {
  color: #fff;
}

.logWarn {
  color: #ffa500;
}

.logError {
  color: #ff4444;
}

.logMessage {
  color: #ddd;
}

.logContext {
  margin-top: 4px;
  padding: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  font-size: 10px;
}

================
File: src/components/ui/PlayerInfo.jsx
================
import React from 'react'
import { useSelector } from 'react-redux'
import { useGame } from '../../context/GameContext'
import styles from './PlayerInfo.module.css'

const PlayerInfo = () => {
  const currentPlayer = useSelector(state => state.game.currentPlayer)
  const turnNumber = useSelector(state => state.game.turnNumber)
  const { stateMachine: { currentState, stateData } } = useGame()

  if (!currentPlayer || currentState === 'setup') return null

  const playerNames = {
    1: 'Red',
    2: 'Blue',
    3: 'Green',
    4: 'Yellow'
  }

  // Get player info from state machine data
  const playerInfo = stateData.players.find(p => p.id === currentPlayer.id)

  return (
    <div className={styles.playerInfo}>
      <div className={styles.turnInfo}>
        <span>Turn {turnNumber}</span>
        <span className={styles.gameState}>State: {currentState}</span>
      </div>
      <div 
        className={styles.currentPlayer}
        style={{ '--player-color': currentPlayer.color }}
      >
        <div className={styles.playerIndicator} />
        <span>{playerNames[currentPlayer.id]}'s Turn</span>
        {playerInfo && (
          <div className={styles.playerStats}>
            <span>Score: {playerInfo.score}</span>
          </div>
        )}
      </div>
    </div>
  )
}

export default PlayerInfo

================
File: src/components/ui/PlayerInfo.module.css
================
.playerInfo {
  background: rgba(0, 0, 0, 0.8);
  border-radius: 8px;
  padding: 12px;
  color: white;
}

.turnInfo {
  font-size: 0.9em;
  opacity: 0.8;
  margin-bottom: 8px;
}

.currentPlayer {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 1.2em;
  font-weight: bold;
}

.playerIndicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background-color: var(--player-color);
  box-shadow: 0 0 10px var(--player-color);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.8;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.playerInfo h3 {
  margin: 0 0 8px 0;
  font-size: 16px;
  font-weight: bold;
}

.playerDetails {
  display: flex;
  flex-direction: column;
  gap: 4px;
  font-size: 14px;
  color: #ddd;
}

================
File: src/components/ui/PowerCard.jsx
================
import React from 'react'
import { useGame } from '../../context/GameContext'

const PowerCard = ({ card, isActive, onSelect }) => {
  const { currentPlayer } = useGame()
  const isDisabled = !isActive || card.cooldown > 0

  return (
    <div
      className={`power-card ${isDisabled ? 'disabled' : ''} ${isActive ? 'active' : ''}`}
      onClick={() => !isDisabled && onSelect(card)}
    >
      <div className="card-header">
        <h3>{card.name}</h3>
        {card.cooldown > 0 && (
          <span className="cooldown">{card.cooldown}</span>
        )}
      </div>
      
      <div className="card-content">
        <p className="description">{card.description}</p>
        <div className="effects">
          {card.effects.map((effect, index) => (
            <div key={index} className="effect">
              <span className="effect-icon">{effect.icon}</span>
              <span className="effect-value">{effect.value}</span>
            </div>
          ))}
        </div>
      </div>

      <style jsx>{`
        .power-card {
          background: rgba(0, 0, 0, 0.7);
          border: 2px solid #444;
          border-radius: 8px;
          padding: 12px;
          margin: 8px;
          width: 200px;
          cursor: pointer;
          transition: all 0.3s ease;
          position: relative;
          overflow: hidden;
        }

        .power-card:hover:not(.disabled) {
          transform: translateY(-2px);
          border-color: #666;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .power-card.active {
          border-color: #00ff00;
          box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        .power-card.disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }

        .card-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
        }

        .card-header h3 {
          margin: 0;
          font-size: 1.1em;
          color: #fff;
        }

        .cooldown {
          background: #ff4444;
          color: white;
          padding: 2px 6px;
          border-radius: 12px;
          font-size: 0.8em;
          font-weight: bold;
        }

        .description {
          color: #ccc;
          font-size: 0.9em;
          margin: 8px 0;
        }

        .effects {
          display: flex;
          gap: 8px;
          margin-top: 8px;
        }

        .effect {
          display: flex;
          align-items: center;
          gap: 4px;
          background: rgba(255, 255, 255, 0.1);
          padding: 4px 8px;
          border-radius: 4px;
        }

        .effect-icon {
          font-size: 1.2em;
        }

        .effect-value {
          color: #fff;
          font-weight: bold;
        }

        /* Power card types */
        .power-card[data-type="magnetic"] {
          border-color: #00ffff;
        }

        .power-card[data-type="wind"] {
          border-color: #00ff00;
        }

        .power-card[data-type="grapple"] {
          border-color: #ff00ff;
        }
      `}</style>
    </div>
  )
}

export default PowerCard

================
File: src/components/ui/PowerCardDeck.jsx
================
import React from 'react'
import { useSelector } from 'react-redux'
import styles from './PowerCardDeck.module.css'

const PowerCardDeck = () => {
  const currentPlayer = useSelector(state => state.game.currentPlayer)
  
  if (!currentPlayer) return null

  return (
    <div className={styles.powerCardDeck}>
      <h3 className={styles.title}>Power Cards</h3>
      <div className={styles.cardContainer}>
        {currentPlayer.powerCards.map(card => (
          <div key={card.id} className={styles.card}>
            <div className={styles.cardHeader}>
              <h4 className={styles.cardName}>{card.name}</h4>
              <span className={styles.cardType}>{card.type}</span>
            </div>
            <p className={styles.cardDescription}>{card.description}</p>
          </div>
        ))}
      </div>
    </div>
  )
}

export default PowerCardDeck

================
File: src/components/ui/PowerCardDeck.module.css
================
.powerCardDeck {
  background: rgba(0, 0, 0, 0.8);
  border-radius: 12px;
  padding: 16px;
  margin: 16px;
  min-width: 240px;
  position: fixed;
  bottom: 16px;
  right: 16px;
  z-index: 1000;
}

.title {
  color: #fff;
  margin: 0 0 16px 0;
  font-size: 1.2em;
  text-align: center;
}

.cardContainer {
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-height: 300px;
  overflow-y: auto;
  padding-right: 8px;
}

.card {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  padding: 12px;
  transition: all 0.2s ease;
}

.card:hover {
  background: rgba(255, 255, 255, 0.15);
  transform: translateY(-2px);
}

.cardHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.cardName {
  margin: 0;
  color: #fff;
  font-size: 1.1em;
}

.cardType {
  background: rgba(255, 255, 255, 0.2);
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  color: #fff;
  text-transform: capitalize;
}

.cardDescription {
  margin: 0;
  color: rgba(255, 255, 255, 0.8);
  font-size: 0.9em;
  line-height: 1.4;
}

/* Scrollbar styling */
.cardContainer::-webkit-scrollbar {
  width: 8px;
}

.cardContainer::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
}

.cardContainer::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

.cardContainer::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

================
File: src/components/ui/PowerCards.jsx
================
import React from 'react'
import { useSelector } from 'react-redux'
import styles from './PowerCards.module.css'

const PowerCard = ({ card, isActive, onClick }) => (
  <div 
    className={`${styles.powerCard} ${isActive ? styles.active : ''}`}
    onClick={onClick}
  >
    <div className={styles.cardIcon}>{card.icon}</div>
    <div className={styles.cardName}>{card.name}</div>
    <div className={styles.cardDescription}>{card.description}</div>
  </div>
)

const PowerCards = () => {
  const currentPlayer = useSelector(state => state.game?.currentPlayer)
  const powerCards = currentPlayer?.powerCards || []

  return (
    <div className={styles.powerCards}>
      {powerCards.map((card, index) => (
        <PowerCard
          key={card.id}
          card={card}
          isActive={card.isActive}
          onClick={() => {
            // Handle card activation
            console.log('Activating card:', card.name)
          }}
        />
      ))}
    </div>
  )
}

export default PowerCards

================
File: src/components/ui/PowerCards.module.css
================
.powerCards {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  max-width: 400px;
}

.powerCard {
  width: 120px;
  height: 160px;
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid #4a90e2;
  border-radius: 8px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(5px);
}

.powerCard:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
}

.powerCard.active {
  border-color: #4CAF50;
  box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
}

.cardIcon {
  font-size: 24px;
  margin-bottom: 8px;
  color: #4a90e2;
}

.cardName {
  font-size: 14px;
  font-weight: bold;
  color: #ffffff;
  text-align: center;
  margin-bottom: 4px;
}

.cardDescription {
  font-size: 12px;
  color: #cccccc;
  text-align: center;
  line-height: 1.2;
}

================
File: src/components/ui/TurnControls.jsx
================
import React, { useState } from 'react'
import { useSelector } from 'react-redux'
import { useGame } from '../../context/GameContext'
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
import styles from './TurnControls.module.css'
import { useFeature } from '../../config/featureFlags'
import { PlayingState } from '../../services/stateMachine/states/PlayingState'
 
const ActionStatusCard = ({ message, onClose }) => (
  <div className={styles.statusCardOverlay} onClick={onClose}>
    <div className={styles.statusCard} onClick={e => e.stopPropagation()}>
      <h4>Action Status</h4>
      <p>{message}</p>
      <button onClick={onClose}>Close</button>
    </div>
  </div>
)

const TurnControls = () => {
  const game = useSelector(state => state.game)
  const currentPlayer = useSelector(state => state.game.currentPlayer)
  const { stateMachineInstance } = useGame()
  const [statusMessage, setStatusMessage] = useState(null)
  const particlesEnabled = useFeature('PARTICLE_EFFECTS')

  const handleActionSelect = (actionType) => {
    // Check if action is available
    if (currentPlayer) {
      const canPerformAction = {
        move: currentPlayer.canMove,
        build: currentPlayer.canBuild,
        roll: currentPlayer.canRoll
      }[actionType]

      if (!canPerformAction) {
        setStatusMessage(`You have already used your ${actionType} action this turn.`)
        logger.info('Action not available', { 
          actionType,
          playerId: currentPlayer.id,
          canMove: currentPlayer.canMove,
          canBuild: currentPlayer.canBuild,
          canRoll: currentPlayer.canRoll
        })
        return
      }
    }

    logger.info('Action card clicked', { 
      actionType,
      currentPlayer,
      gameState: game?.gameState,
      hasStateMachineInstance: !!stateMachineInstance,
      particlesEnabled
    });

    if (!currentPlayer || !stateMachineInstance) {
      setStatusMessage('Cannot perform action: Game or StateMachine not ready')
      return;
    }

    // Get the current state using the instance
    const currentState = stateMachineInstance.getCurrentState(); 

    // Check if the current state is the playing state and has the method
    if (currentState instanceof PlayingState && typeof currentState.selectAction === 'function') {
      try {
        // Call selectAction on the retrieved current state instance
        currentState.selectAction(actionType, currentPlayer.position, particlesEnabled);
        logger.info('Action selected in state machine', {
          actionType,
          playerId: currentPlayer.id,
          position: currentPlayer.position,
          color: currentPlayer.color,
          particles: particlesEnabled
        });
      } catch (error) {
        setStatusMessage(`Failed to perform ${actionType} action: ${error.message}`)
        logger.error('Failed to select action', {
          actionType,
          error: error instanceof Error ? error.message : 'Unknown error',
          playerId: currentPlayer.id
        });
      }
    } else {
      setStatusMessage('Game is not in a playable state or action not supported')
      logger.warn('Current state does not support selectAction', {
        currentStateName: currentState?.getName()
      });
    }
  }

  const isActionDisabled = (actionType) => {
    // Basic check: disable if game or player is not ready
    if (!game || !currentPlayer) {
      return true;
    }
    
    // Check action-specific flags from the currentPlayer object
    switch (actionType) {
      case 'move':
        return !currentPlayer.canMove;
      case 'build':
        return !currentPlayer.canBuild;
      case 'roll':
        // Keep existing roll logic (e.g., disable if already rolled)
        // return game.diceRolled || !currentPlayer.canRoll;
        return !currentPlayer.canRoll; // Assuming canRoll covers the 'already rolled' state
      default:
        return false; // Unknown action type, don't disable
    }
  };

  // Re-add log before return
  logger.info("Rendering with currentPlayer:", JSON.stringify(currentPlayer)); 

  // Always render the controls, even without currentPlayer
  return (
    <div className={styles.turnControls}>
      <h3 className={styles.title}>Actions</h3>
      <div className={styles.actionCards}>
        {/* Move Action Card */}
        <button 
          className={`${styles.actionCard} ${game?.selectedAction === 'move' ? styles.selected : ''}`}
          onClick={() => handleActionSelect('move')}
          disabled={isActionDisabled('move')}
        >
          <h4>Move</h4>
          <p>Move one space up/down on adjacent cubes</p>
        </button>

        {/* Build Action Card */}
        <button 
          className={`${styles.actionCard} ${game?.selectedAction === 'build' ? styles.selected : ''}`}
          onClick={() => handleActionSelect('build')}
          disabled={isActionDisabled('build')}
        >
          <h4>Build</h4>
          <p>Stack a cube on the ground or on other cubes</p>
        </button>

        {/* Roll Action Card */}
        <button 
          className={`${styles.actionCard} ${game?.selectedAction === 'roll' ? styles.selected : ''}`}
          onClick={() => handleActionSelect('roll')}
          disabled={isActionDisabled('roll')}
        >
          <h4>Roll</h4>
          <p>Roll action (details to be added)</p>
        </button>
      </div>

      {statusMessage && (
        <ActionStatusCard 
          message={statusMessage} 
          onClose={() => setStatusMessage(null)} 
        />
      )}
    </div>
  )
}

export default TurnControls

================
File: src/components/ui/TurnControls.module.css
================
.turnControls {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.title {
  margin: 0 0 16px 0;
  font-size: 1.2em;
  text-align: center;
  color: white;
}

.actionCards {
  display: flex;
  gap: 12px;
  justify-content: center;
  width: 100%;
}

.actionCard {
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  padding: 12px;
  min-width: 120px;
  cursor: pointer;
  transition: all 0.2s ease;
  color: white;
  text-align: left;
  flex: 1;
  max-width: 200px;
}

.actionCard:hover:not(:disabled) {
  background: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.actionCard:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.actionCard.selected {
  background: rgba(255, 255, 255, 0.3);
  border-color: rgba(255, 255, 255, 0.5);
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
}

.actionCard h4 {
  margin: 0 0 8px 0;
  font-size: 1.1em;
  color: white;
}

.actionCard p {
  margin: 0;
  font-size: 0.9em;
  opacity: 0.8;
  line-height: 1.4;
  color: white;
}

.statusCardOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000;
  backdrop-filter: blur(2px);
}

.statusCard {
  background: rgba(30, 30, 30, 0.95);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  padding: 20px;
  min-width: 300px;
  max-width: 400px;
  text-align: center;
  animation: slideIn 0.2s ease-out;
}

.statusCard h4 {
  margin: 0 0 12px 0;
  font-size: 1.2em;
  color: white;
}

.statusCard p {
  margin: 0 0 16px 0;
  color: #ccc;
  line-height: 1.4;
}

.statusCard button {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 6px;
  padding: 8px 16px;
  color: white;
  cursor: pointer;
  transition: all 0.2s ease;
}

.statusCard button:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-1px);
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

================
File: src/components/GameBoard.tsx
================
import React, { useEffect, useRef } from 'react';
import { useGame } from '../context/GameContext';
import { ActionManager } from '../services/ActionManager';
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
import {
  Scene,
  PerspectiveCamera,
  WebGLRenderer,
  Color,
  BoxGeometry,
  MeshStandardMaterial,
  Mesh,
  DirectionalLight,
  AmbientLight,
  Raycaster,
  Vector2,
  Vector3,
  Object3D
} from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

export const GameBoard: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const { game, stateMachine } = useGame();
  const actionManager = ActionManager.getInstance();
  const sceneRef = useRef<Scene | null>(null);
  const cubesRef = useRef<Map<string, Mesh>>(new Map());

  useEffect(() => {
    if (!canvasRef.current) return;

    logger.info('Initializing game board');

    // Scene setup
    const scene = new Scene();
    sceneRef.current = scene;
    scene.background = new Color(0x87ceeb);

    // Camera setup
    const camera = new PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);

    // Renderer setup
    const renderer = new WebGLRenderer({
      canvas: canvasRef.current,
      antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // Lighting
    const directionalLight = new DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    const ambientLight = new AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Set the scene in the ActionManager
    actionManager.setScene(scene);

    // Create base grid
    const gridSize = 5;
    for (let x = -gridSize; x <= gridSize; x++) {
      for (let z = -gridSize; z <= gridSize; z++) {
        const geometry = new BoxGeometry(1, 0.1, 1);
        const material = new MeshStandardMaterial({ 
          color: 0x808080,
          transparent: true,
          opacity: 0.5
        });
        const cube = new Mesh(geometry, material);
        cube.position.set(x, -0.05, z);
        scene.add(cube);
      }
    }

    logger.info('Game board initialized' + JSON.stringify({
      gridSize,
      cameraPosition: camera.position
    }));

    // Handle window resize
    const handleResize = () => {
      if (!canvasRef.current) return;
      
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      logger.debug('Window resized' + JSON.stringify({
        width: window.innerWidth,
        height: window.innerHeight
      }));
    };

    window.addEventListener('resize', handleResize);

    // Raycaster setup
    const raycaster = new Raycaster();
    const mouse = new Vector2();

    // Handle cube clicks
    const handleCubeClick = (event: MouseEvent) => {
      if (!canvasRef.current) return;

      // Calculate mouse position in normalized device coordinates
      const rect = canvasRef.current.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      // Update the picking ray with the camera and mouse position
      raycaster.setFromCamera(mouse, camera);

      // Calculate objects intersecting the picking ray
      const intersects = raycaster.intersectObjects(scene.children);

      if (intersects.length > 0) {
        const intersection = intersects[0];
        const position = intersection.point;

        // Round to grid coordinates
        const gridPosition = {
          x: Math.round(position.x),
          y: Math.round(position.y),
          z: Math.round(position.z)
        };

        logger.info('Cube clicked', {
          rawPosition: position,
          gridPosition,
          intersectionDistance: intersection.distance
        });

        const currentAction = actionManager.getCurrentAction();
        const playingState = stateMachine?.getCurrentState();

        if (!playingState || !('handleMove' in playingState)) {
          logger.warn('Invalid game state for handling cube clicks');
          return;
        }

        if (currentAction.type === 'move') {
          if (actionManager.isValidActionPosition(gridPosition)) {
            playingState.handleMove(gridPosition);
            logger.info('Move action processed', { position: gridPosition });
          } else {
            logger.warn('Invalid move position', { position: gridPosition });
          }
        } else if (currentAction.type === 'build') {
          if (actionManager.isValidActionPosition(gridPosition)) {
            playingState.handleBuild(gridPosition);
            logger.info('Build action processed', { position: gridPosition });
          } else {
            logger.warn('Invalid build position', { position: gridPosition });
          }
        }
      }
    };

    canvasRef.current.addEventListener('click', handleCubeClick);

    // Animation loop
    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    // Cleanup
    return () => {
      logger.info('Cleaning up game board');
      window.removeEventListener('resize', handleResize);
      if (canvasRef.current) {
        canvasRef.current.removeEventListener('click', handleCubeClick);
      }
      controls.dispose();
      renderer.dispose();
    };
  }, [stateMachine]);

  // Update cubes when game state changes
  useEffect(() => {
    if (!sceneRef.current || !game) return;

    const scene = sceneRef.current;
    const cubes = cubesRef.current;

    // Remove old cubes
    cubes.forEach((cube) => {
      scene.remove(cube);
      cube.geometry.dispose();
      (cube.material as MeshStandardMaterial).dispose();
    });
    cubes.clear();

    // Add new cubes from game state
    if (game.board) {
      game.board.forEach((cube: any) => {
        const geometry = new BoxGeometry(1, 1, 1);
        const material = new MeshStandardMaterial({ color: 0x00ff00 });
        const mesh = new Mesh(geometry, material);
        mesh.position.set(cube.position.x, cube.position.y, cube.position.z);
        scene.add(mesh);
        cubes.set(cube.id, mesh);
      });

      logger.info('Updated game board cubes', {
        cubeCount: game.board.length
      });
    }
  }, [game?.board]);

  return <canvas ref={canvasRef} />;
};

================
File: src/config/featureFlags.js
================
/**
 * @typedef {Object} FeatureFlags
 * @property {boolean} TOAST_NOTIFICATIONS - Enable toast notifications for console logs
 * @property {boolean} PARTICLE_EFFECTS - Enable particle effects for highlights and players
 */

/**
 * Feature flags configuration
 * @type {FeatureFlags}
 */
export const FEATURE_FLAGS = {
  TOAST_NOTIFICATIONS: false, // Set to false to disable toast notifications
  PARTICLE_EFFECTS: true // Set to false to disable particle effects
}

/**
 * Get the value of a feature flag
 * @param {keyof FeatureFlags} flag - The feature flag to check
 * @returns {boolean} - The value of the feature flag
 */
export const isFeatureEnabled = (flag) => {
  if (!(flag in FEATURE_FLAGS)) {
    console.warn(`Feature flag "${flag}" does not exist`)
    return false
  }
  return FEATURE_FLAGS[flag]
}

/**
 * Hook to check if a feature is enabled
 * @param {keyof FeatureFlags} flag - The feature flag to check
 * @returns {boolean} - Whether the feature is enabled
 */
export const useFeature = (flag) => {
  return isFeatureEnabled(flag)
}

================
File: src/config/GameConfig.ts
================
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();

export interface Direction {
  x: number;
  z: number;
}

export interface MovementConfig {
  maxClimbHeight: number;      // Maximum height a player can climb (default: 1)
  maxDescendHeight: number;    // Maximum height a player can descend (default: 0 for unlimited)
  allowedDirections: Direction[]; // Array of allowed movement directions
}

export interface BuildConfig {
  maxBuildHeight: number;      // Maximum height difference for building (0 for unlimited)
  requireAdjacent: boolean;    // Whether building requires adjacent position
}

export interface HighlightConfig {
  moveHighlightColor: string;  // Color for movement highlights
  buildHighlightColor: string; // Color for build highlights
  particleEffect: boolean;     // Whether to show particle effects
}

export interface BoardConfig {
  size: number;               // Size of the board (NxN)
}

export interface GameConfig {
  movement: MovementConfig;
  build: BuildConfig;
  highlight: HighlightConfig;
  board: BoardConfig;
}

class GameConfigManager {
  private static instance: GameConfigManager;
  private config: GameConfig;

  private constructor() {
    this.config = this.getDefaultConfig();
    logger.info('Game configuration initialized with default values');
  }

  public static getInstance(): GameConfigManager {
    if (!GameConfigManager.instance) {
      GameConfigManager.instance = new GameConfigManager();
    }
    return GameConfigManager.instance;
  }

  private getDefaultConfig(): GameConfig {
    return {
      movement: {
        maxClimbHeight: 1,
        maxDescendHeight: 0, // 0 means unlimited
        allowedDirections: [
          { x: 0, z: 1 },  // north
          { x: 0, z: -1 }, // south
          { x: 1, z: 0 },  // east
          { x: -1, z: 0 }  // west
        ]
      },
      build: {
        maxBuildHeight: 0, // 0 means unlimited
        requireAdjacent: true
      },
      highlight: {
        moveHighlightColor: '#ffffff',
        buildHighlightColor: '#00ff00',
        particleEffect: true
      },
      board: {
        size: 8 // Default 8x8 board
      }
    };
  }

  public getConfig(): GameConfig {
    return { ...this.config };
  }

  public updateConfig(newConfig: Partial<GameConfig>): void {
    this.config = {
      ...this.config,
      ...newConfig
    };
    logger.info('Game configuration updated'+ JSON.stringify({ newConfig }));
  }

  public validateConfig(): boolean {
    const isValid = 
      this.config.movement.maxClimbHeight >= 0 &&
      this.config.movement.maxDescendHeight >= 0 &&
      this.config.movement.allowedDirections.length > 0 &&
      this.config.build.maxBuildHeight >= 0 &&
      this.config.board.size > 0;

    if (!isValid) {
      logger.error('Invalid game configuration detected'+ JSON.stringify({ config: this.config }));
    }

    return isValid;
  }
}

export const gameConfig = GameConfigManager.getInstance();

================
File: src/constants/GameConstants.ts
================
export class GameConstants {
  // Game States
  static readonly STATE_SETUP = 'setup';
  static readonly STATE_PLAYING = 'playing';
  static readonly STATE_GAME_OVER = 'gameOver';
  static readonly STATE_ENDED = 'ended';

  // Game Phases
  static readonly PHASE_SETUP = 'setup';
  static readonly PHASE_PLAYING = 'playing';
  static readonly PHASE_ENDED = 'ended';

  // Local Storage Keys
  static readonly STORAGE_GAME_STATE = 'gameState';
  static readonly STORAGE_SAVED_GAME_PREFIX = 'savedGame_';

  // Player Colors
  static readonly PLAYER_COLOR_RED = '#f44336';
  static readonly PLAYER_COLOR_BLUE = '#2196F3';
  static readonly PLAYER_COLOR_GREEN = '#4CAF50';
  static readonly PLAYER_COLOR_YELLOW = '#FFC107';

  // Board Objects
  static readonly OBJECT_TYPE_GROUND = 'ground';
  static readonly OBJECT_TYPE_CUBE = 'cube';
  static readonly OBJECT_TYPE_PLAYER = 'player';

  // Action Types
  static readonly ACTION_NONE = 'none';
  static readonly ACTION_BUILD = 'build';
  static readonly ACTION_MOVE = 'move';
  static readonly ACTION_ROLL = 'roll';

  // UI Elements
  static readonly UI_SELECTED_CLASS = 'selected';

  // Default Values
  static readonly DEFAULT_BOARD_SIZE = 8;
  static readonly MIN_PLAYERS = 2;
  static readonly MAX_PLAYERS = 4;
  static readonly DEFAULT_MAGNETIC_FIELD_STRENGTH = 1.0;
  static readonly MAX_LOG_ENTRIES = 50;

  // Highlight Colors
  static readonly HIGHLIGHT_COLOR_DEFAULT = '#ffffff';
  static readonly HIGHLIGHT_COLOR_VALID = '#00ff00';
  static readonly HIGHLIGHT_OPACITY = 0.6;
}

================
File: src/context/GameContext.jsx
================
import React, { createContext, useContext, useEffect, useRef, useMemo } from 'react'
import { useDispatch, useSelector } from 'react-redux'
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
import { GameLogic } from '../services/GameLogic'
import { initializeGame } from '../store/gameReducer'
import { useGameStateMachine } from '../hooks/useGameStateMachine'

const GameContext = createContext()

export const useGame = () => {
  const context = useContext(GameContext)
  if (!context) {
    throw new Error('useGame must be used within a GameProvider')
  }
  return context
}

export const GameProvider = ({ children }) => {
  const dispatch = useDispatch()
  const game = useSelector(state => state.game)
  const gameLogic = useMemo(() => GameLogic.getInstance(), [])
  const initialized = useRef(false)
  const syncInProgress = useRef(false)
  
  // Initialize state machine
  const { 
    currentState, 
    stateData, 
    setup, 
    playing, 
    gameOver,
    stateMachine: stateMachineInstance
  } = useGameStateMachine()

  // Create state machine interface - memoize to prevent unnecessary recreation
  const stateMachineInterface = useMemo(() => ({
    transitionTo: (state) => {
      logger.info('State machine transition requested', { 
        from: currentState, 
        to: state 
      })

      // First transition the state machine
      if (stateMachineInstance) {
        stateMachineInstance.transitionTo(state)
        logger.info('State machine transitioned', {
          from: currentState,
          to: state,
          stateData
        })
      }
    },
    
    getStateData: () => stateData,
    updateStateData: (newData) => {
      switch (currentState) {
        case 'playing':
          if (playing) {
            playing.makeMove({
              type: 'updateState',
              data: newData
            })
          }
          break
        case 'gameOver':
          if (gameOver) {
            gameOver.updateFinalState(newData)
          }
          break
        default:
          break
      }
    }
  }), [currentState, stateData, playing, gameOver, stateMachineInstance])

  // Initialize game once
  useEffect(() => {
    const initGame = () => {
      if (!initialized.current) {
        logger.info('Initializing game via GameLogic service')
        
        // 1. Initialize the GameLogic service state
        gameLogic.initializeGame(); // Default player count
        
        // 2. Get the initial state *from* the GameLogic service
        const initialGameState = gameLogic.getGameState();
        logger.info('Retrieved initial state from GameLogic', { initialGameState });
        
        // 3. Dispatch action to set Redux state based on GameLogic state
        dispatch(initializeGame(initialGameState))
        
        // Optional: Attach state machine *after* GameLogic and Redux are initialized
        gameLogic.setStateMachine(stateMachineInterface)
        
        // Mark as initialized
        initialized.current = true
      }
    }

    initGame()
    // Dependencies: only dispatch. gameLogic instance is stable due to useMemo.
    // stateMachineInterface might be needed if attach happens here.
  }, [dispatch, gameLogic, stateMachineInterface]) 

  // Single effect to handle state synchronization
  useEffect(() => {
    if (!initialized.current || syncInProgress.current) {
      return;
    }

    syncInProgress.current = true;
    try {
      // Case 1: Game is initialized and we need to transition to playing
      if (game.currentPlayer && stateMachineInstance && currentState !== 'playing' && game.gameState === 'playing') {
        const boardArray = Object.values(game.cubes).map(cube => ({
          id: cube.id,
          position: cube.position
        }));

        stateMachineInstance.updateStateData({
          players: game.players.map(player => ({
            id: player.id.toString(),
            name: `Player ${player.id}`,
            score: player.score,
            position: player.position,
            color: player.color
          })),
          currentPlayerId: game.currentPlayer.id.toString(),
          board: boardArray,
          moveHistory: []
        });

        logger.info('Game state synchronized with Redux', {
          gameState: game.gameState,
          currentPlayer: game.currentPlayer,
          machineState: currentState
        });
      }
      // Case 2: State machine state changed and we need to update Redux
      else if (game.gameState !== currentState && currentState && currentState !== 'setup') {
        dispatch({ 
          type: 'game/setState', 
          payload: currentState 
        });
        
        logger.info('Redux state synchronized with state machine', {
          reduxState: game.gameState,
          machineState: currentState
        });
      }
      // Case 3: Setup is complete and we need to start the game
      else if (stateData?.players.length > 0 && currentState === 'setup' && game.gameState === 'setup') {
        setup?.startGame();
        logger.info('Setup complete, starting game');
      }
    } finally {
      syncInProgress.current = false;
    }
  }, [game.currentPlayer, game.gameState, currentState, stateData, stateMachineInstance, setup, dispatch, game.players, game.cubes])

  const value = {
    game,
    dispatch,
    gameLogic,
    currentPlayer: game.currentPlayer,
    stateMachine: {
      currentState,
      stateData,
      setup,
      playing,
      gameOver
    },
    stateMachineInstance
  }

  return (
    <GameContext.Provider value={value}>
      {children}
    </GameContext.Provider>
  )
}

================
File: src/game/ActionManager.js
================
const highlightValidBuildPositions = () => {
  const validPositions = [];
  for (let x = -2; x <= 2; x++) {
    for (let z = -2; z <= 2; z++) {
      const position = [x, 0, z];
      if (isValidBuildPosition(position)) {
        validPositions.push(position);
      }
    }
  }
  console.log('Valid build positions:', validPositions);
  logger.info('Valid build positions found', { facesCount: validPositions.length, positions: validPositions });
  highlightPositions(validPositions, { color: 0x00ff00, opacity: 0.5 });
};

================
File: src/game/gameLogic.js
================
const isValidBuildPosition = (position) => {
  // Round the position to match the grid
  const roundedPosition = [
    Math.round(position[0] * 2) / 2,
    Math.round(position[1]),
    Math.round(position[2] * 2) / 2
  ];
  
  // Check if the position is within the board boundaries
  if (roundedPosition[0] < -2 || roundedPosition[0] > 2 || 
      roundedPosition[2] < -2 || roundedPosition[2] > 2) {
    logger.warn('Position out of bounds', { position: roundedPosition });
    return false;
  }

  // Check if there is already a cube at the position
  for (const cubeId in cubes) {
    const cube = cubes[cubeId];
    if (Math.abs(cube.position[0] - roundedPosition[0]) < 0.1 && 
        Math.abs(cube.position[2] - roundedPosition[2]) < 0.1) {
      logger.warn('Position already occupied by a cube', { position: roundedPosition });
      return false;
    }
  }

  // Check if the position is adjacent to the current player
  const playerPosition = currentPlayer.position;
  const isAdjacent = Math.abs(playerPosition[0] - roundedPosition[0]) <= 1 && 
                     Math.abs(playerPosition[2] - roundedPosition[2]) <= 1;
  if (!isAdjacent) {
    logger.warn('Position not adjacent to player', { 
      playerPosition, 
      buildPosition: roundedPosition 
    });
    return false;
  }

  return true;
};

build: (position) => {
  // Round the position to match the grid
  const roundedPosition = [
    Math.round(position[0] * 2) / 2,
    Math.round(position[1]),
    Math.round(position[2] * 2) / 2
  ];
  
  // Check if the position is valid for building
  if (!isValidBuildPosition(roundedPosition)) {
    logger.warn('Invalid build position', { position: roundedPosition });
    return false;
  }

  // Add a new cube at the position
  const newCubeId = `cube-${Object.keys(cubes).length + 1}`;
  cubes[newCubeId] = {
    id: newCubeId,
    position: roundedPosition,
    owner: currentPlayer.id
  };

  // Update the current player's canBuild flag
  currentPlayer.canBuild = false;

  logger.info('Cube built', { cubeId: newCubeId, position: roundedPosition, owner: currentPlayer.id });
  return true;
},

================
File: src/hooks/useGameStateMachine.ts
================
import { useState, useEffect, useCallback, useRef } from 'react';
import { GameStateMachine, GameStateData } from '../services/stateMachine/GameStateMachine';
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;

// Singleton instance
let stateMachineInstance: GameStateMachine | null = null;

export const useGameStateMachine = () => {
  // Create the instance only once
  if (!stateMachineInstance) {
    logger.info('Creating GameStateMachine singleton instance');
    stateMachineInstance = new GameStateMachine();
  }

  const [currentState, setCurrentState] = useState(stateMachineInstance.getCurrentStateName());
  const [stateData, setStateData] = useState<GameStateData>(stateMachineInstance.getStateData());
  const initialized = useRef(false);

  // Update local state when state machine changes
  useEffect(() => {
    const updateState = () => {
      const newState = stateMachineInstance!.getCurrentStateName();
      const newStateData = stateMachineInstance!.getStateData();
      
      if (newState !== currentState) {
        logger.info('State changed', { from: currentState, to: newState });
        setCurrentState(newState);
      }
      
      if (JSON.stringify(newStateData) !== JSON.stringify(stateData)) {
        logger.info('State data changed', { oldData: stateData, newData: newStateData });
        setStateData(newStateData);
      }
    };

    const updateInterval = setInterval(updateState, 100); // Poll for updates every 100ms
    updateState(); // Initial update

    return () => clearInterval(updateInterval);
  }, [currentState, stateData]);

  // Load persisted state on mount
  useEffect(() => {
    if (!initialized.current) {
      const loaded = stateMachineInstance!.loadPersistedState();
      if (!loaded) {
        logger.info('No persisted state found, starting in setup state');
        stateMachineInstance!.transitionTo('setup');
      }
      initialized.current = true;
    }
  }, []);

  // Wrapper functions for state machine operations
  const saveGame = useCallback((name: string) => {
    stateMachineInstance!.saveGame(name);
  }, []);

  const loadGame = useCallback((name: string) => {
    return stateMachineInstance!.loadGame(name);
  }, []);

  const listSavedGames = useCallback(() => {
    return stateMachineInstance!.listSavedGames();
  }, []);

  // State-specific operations
  const setupOperations = {
    addPlayer: useCallback((name: string) => {
      if (currentState === 'setup') {
        (stateMachineInstance as any).states.get('setup').addPlayer(name);
      }
    }, [currentState]),

    startGame: useCallback(() => {
      if (currentState === 'setup') {
        logger.info('Starting game from setup state');
        (stateMachineInstance as any).states.get('setup').startGame();
      }
    }, [currentState])
  };

  const playingOperations = {
    makeMove: useCallback((move: any) => {
      if (currentState === 'playing') {
        (stateMachineInstance as any).states.get('playing').makeMove(move);
      }
    }, [currentState]),

    getCurrentPlayer: useCallback(() => {
      if (currentState === 'playing') {
        return (stateMachineInstance as any).states.get('playing').getCurrentPlayer();
      }
      return null;
    }, [currentState]),

    selectAction: useCallback((actionType: string, position: any) => {
      if (currentState === 'playing') {
        logger.info('Selecting action in playing state', { actionType, position });
        (stateMachineInstance as any).states.get('playing').selectAction(actionType, position);
      }
    }, [currentState])
  };

  const gameOverOperations = {
    getWinner: useCallback(() => {
      if (currentState === 'gameOver') {
        return (stateMachineInstance as any).states.get('gameOver').getWinner();
      }
      return null;
    }, [currentState]),

    getFinalScores: useCallback(() => {
      if (currentState === 'gameOver') {
        return (stateMachineInstance as any).states.get('gameOver').getFinalScores();
      }
      return [];
    }, [currentState]),

    startNewGame: useCallback(() => {
      if (currentState === 'gameOver') {
        (stateMachineInstance as any).states.get('gameOver').startNewGame();
      }
    }, [currentState])
  };

  return {
    currentState,
    stateData,
    saveGame,
    loadGame,
    listSavedGames,
    setup: setupOperations,
    playing: playingOperations,
    gameOver: gameOverOperations,
    stateMachine: stateMachineInstance
  };
};

================
File: src/services/highlight/BuildHighlighter.ts
================
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { gameConfig } from '../../config/GameConfig';
import { Position } from '../BoardStateManager';
import {
  Color,
  Mesh,
  MeshBasicMaterial,
  Scene,
  BoxGeometry,
  Points,
  BufferGeometry,
  PointsMaterial,
  BufferAttribute,
  DoubleSide
} from 'three';

export interface BuildHighlightOptions {
  color: string;
  opacity?: number;
  particleEffect?: boolean;
}

export class BuildHighlighter {
  private static instance: BuildHighlighter;
  private highlightedMeshes: Mesh[] = [];

  private constructor() {
    logger.info('Build highlighter initialized');
  }

  public static getInstance(): BuildHighlighter {
    if (!BuildHighlighter.instance) {
      BuildHighlighter.instance = new BuildHighlighter();
    }
    return BuildHighlighter.instance;
  }

  /**
   * Highlights valid build positions
   * @param positions Array of valid positions to highlight
   * @param scene Three.js scene to add highlights to
   * @param options Highlight customization options
   */
  public highlightValidBuildPositions(
    positions: Position[],
    scene: Scene,
    options?: BuildHighlightOptions
  ): void {
    logger.info('Highlighting valid build positions', {
      positions,
      options
    });

    this.clearHighlights(scene);

    const config = gameConfig.getConfig();
    const highlightColor = options?.color || config.highlight.buildHighlightColor;
    const opacity = options?.opacity || 0.3;

    positions.forEach(position => {
      const highlight = this.createBuildHighlightMesh(position, highlightColor, opacity);
      scene.add(highlight);
      this.highlightedMeshes.push(highlight);

      if ((options?.particleEffect ?? config.highlight.particleEffect)) {
        this.addParticleEffect(position, scene, highlightColor);
      }
    });
  }

  /**
   * Clears all current highlights from the scene
   * @param scene Three.js scene to remove highlights from
   */
  public clearHighlights(scene: Scene): void {
    logger.info('Clearing build highlights');
    
    this.highlightedMeshes.forEach(mesh => {
      scene.remove(mesh);
      mesh.geometry.dispose();
      (mesh.material as MeshBasicMaterial).dispose();
    });
    
    this.highlightedMeshes = [];
  }

  private createBuildHighlightMesh(
    position: Position,
    color: string,
    opacity: number
  ): Mesh {
    // Create a transparent cube to show where the block would be placed
    const geometry = new BoxGeometry(1, 1, 1);
    const material = new MeshBasicMaterial({
      color: new Color(color),
      transparent: true,
      opacity: opacity,
      side: DoubleSide
    });

    const mesh = new Mesh(geometry, material);
    mesh.position.set(position.x, position.y, position.z); // Place at exact position

    return mesh;
  }

  private addParticleEffect(
    position: Position,
    scene: Scene,
    color: string
  ): void {
    // Create rising particle effect for build locations
    const particles = new Points(
      new BufferGeometry(),
      new PointsMaterial({
        color: new Color(color),
        size: 0.1,
        transparent: true,
        opacity: 0.6
      })
    );

    const particleCount = 8;
    const positions = new Float32Array(particleCount * 3);

    // Create particles in a column above the build position
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = position.x + (Math.random() - 0.5) * 0.2;
      positions[i * 3 + 1] = position.y + (i / particleCount) * 1.5;
      positions[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.2;
    }

    particles.geometry.setAttribute(
      'position',
      new BufferAttribute(positions, 3)
    );

    scene.add(particles);
    this.highlightedMeshes.push(particles as unknown as Mesh);
  }
}

================
File: src/services/highlight/MovementHighlighter.ts
================
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { gameConfig } from '../../config/GameConfig';
import { Position } from '../BoardStateManager';
import {
  Color,
  Mesh,
  MeshBasicMaterial,
  Scene,
  PlaneGeometry,
  Points,
  BufferGeometry,
  PointsMaterial,
  BufferAttribute,
  DoubleSide
} from 'three';

export interface HighlightOptions {
  color: string;
  opacity?: number;
  particleEffect?: boolean;
}

export class MovementHighlighter {
  private static instance: MovementHighlighter;
  private highlightedMeshes: Mesh[] = [];

  private constructor() {
    logger.info('Movement highlighter initialized');
  }

  public static getInstance(): MovementHighlighter {
    if (!MovementHighlighter.instance) {
      MovementHighlighter.instance = new MovementHighlighter();
    }
    return MovementHighlighter.instance;
  }

  /**
   * Highlights valid move positions
   * @param positions Array of valid positions to highlight
   * @param scene Three.js scene to add highlights to
   * @param options Highlight customization options
   */
  public highlightValidMoves(
    positions: Position[],
    scene: Scene,
    options?: HighlightOptions
  ): void {
    logger.info('Highlighting valid moves', { 
      positions,
      options 
    });

    this.clearHighlights(scene);

    const config = gameConfig.getConfig();
    const highlightColor = options?.color || config.highlight.moveHighlightColor;
    const opacity = options?.opacity || 0.5;

    positions.forEach(position => {
      // Create highlight at the position's actual height
      const highlight = this.createHighlightMesh(position, highlightColor, opacity);
      scene.add(highlight);
      this.highlightedMeshes.push(highlight);

      if ((options?.particleEffect ?? config.highlight.particleEffect)) {
        this.addParticleEffect(position, scene, highlightColor);
      }

      logger.info('Added highlight', {
        position,
        color: highlightColor,
        opacity
      });
    });
  }

  /**
   * Clears all current highlights from the scene
   * @param scene Three.js scene to remove highlights from
   */
  public clearHighlights(scene: Scene): void {
    logger.info('Clearing movement highlights');
    
    this.highlightedMeshes.forEach(mesh => {
      scene.remove(mesh);
      mesh.geometry.dispose();
      (mesh.material as MeshBasicMaterial).dispose();
    });
    
    this.highlightedMeshes = [];
  }

  private createHighlightMesh(
    position: Position,
    color: string,
    opacity: number
  ): Mesh {
    // Create a plane geometry for the highlight
    const geometry = new PlaneGeometry(1, 1);
    const material = new MeshBasicMaterial({
      color: new Color(color),
      transparent: true,
      opacity: opacity,
      side: DoubleSide
    });

    const mesh = new Mesh(geometry, material);
    
    // Position the highlight at the specified height (y) plus a small offset
    // If position.y is 1, it means we're highlighting the top of a cube
    mesh.position.set(
      position.x, 
      position.y + 0.01, // Small offset to prevent z-fighting
      position.z
    );
    mesh.rotation.x = -Math.PI / 2; // Lay flat

    logger.info('Created highlight mesh', {
      position: mesh.position,
      color,
      opacity
    });

    return mesh;
  }

  private addParticleEffect(
    position: Position,
    scene: Scene,
    color: string
  ): void {
    const particles = new Points(
      new BufferGeometry(),
      new PointsMaterial({
        color: new Color(color),
        size: 0.1,
        transparent: true,
        opacity: 0.6
      })
    );

    const particleCount = 5;
    const positions = new Float32Array(particleCount * 3);

    // Position particles at the same height as the highlight
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = position.x + (Math.random() - 0.5) * 0.5;
      positions[i * 3 + 1] = position.y + Math.random() * 0.5; // Use position's height
      positions[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.5;
    }

    particles.geometry.setAttribute(
      'position',
      new BufferAttribute(positions, 3)
    );

    scene.add(particles);
    this.highlightedMeshes.push(particles as unknown as Mesh);
  }
}

================
File: src/services/logger/GameLogger.ts
================
export enum LogLevel {
  DEBUG = 'DEBUG',
  INFO = 'INFO',
  WARN = 'WARN',
  ERROR = 'ERROR'
}

export interface LogEntry {
  timestamp: number;
  level: LogLevel;
  category: string;
  message: string;
  data?: any;
}

class GameLogger {
  private static instance: GameLogger;
  private logs: LogEntry[] = [];
  private maxLogs: number = 1000;

  private constructor() {}

  static getInstance(): GameLogger {
    if (!GameLogger.instance) {
      GameLogger.instance = new GameLogger();
    }
    return GameLogger.instance;
  }

  private log(level: LogLevel, category: string, message: string, data?: any) {
    const entry: LogEntry = {
      timestamp: Date.now(),
      level,
      category,
      message,
      data
    };

    this.logs.push(entry);
    
    // Keep logs under maxLogs limit
    if (this.logs.length > this.maxLogs) {
      this.logs = this.logs.slice(-this.maxLogs);
    }

    // Also log to console with appropriate method
    const consoleData = data ? [message, data] : [message];
    switch (level) {
      case LogLevel.DEBUG:
        console.debug(`[${category}]`, ...consoleData);
        break;
      case LogLevel.INFO:
        console.info(`[${category}]`, ...consoleData);
        break;
      case LogLevel.WARN:
        console.warn(`[${category}]`, ...consoleData);
        break;
      case LogLevel.ERROR:
        console.error(`[${category}]`, ...consoleData);
        break;
    }

    // Store in localStorage for persistence
    this.persistLogs();
  }

  debug(category: string, message: string, data?: any) {
    this.log(LogLevel.DEBUG, category, message, data);
  }

  info(category: string, message: string, data?: any) {
    this.log(LogLevel.INFO, category, message, data);
  }

  warn(category: string, message: string, data?: any) {
    this.log(LogLevel.WARN, category, message, data);
  }

  error(category: string, message: string, data?: any) {
    this.log(LogLevel.ERROR, category, message, data);
  }

  getLogs(level?: LogLevel): LogEntry[] {
    return level 
      ? this.logs.filter(log => log.level === level)
      : [...this.logs];
  }

  getLatestLogs(count: number = 50): LogEntry[] {
    return this.logs.slice(-count);
  }

  clearLogs(): void {
    this.logs = [];
    localStorage.removeItem('gameLogs');
  }

  private persistLogs(): void {
    localStorage.setItem('gameLogs', JSON.stringify(this.logs));
  }

  loadPersistedLogs(): void {
    const savedLogs = localStorage.getItem('gameLogs');
    if (savedLogs) {
      try {
        this.logs = JSON.parse(savedLogs);
      } catch (error) {
        console.error('Error loading persisted logs:', error);
        this.logs = [];
      }
    }
  }
}

export const logger = GameLogger.getInstance();

================
File: src/services/stateMachine/states/GameOverState.ts
================
import { GameState } from './GameState';
import { GameStateMachine, StateData } from '../GameStateMachine';
import { GameConstants } from '../../../constants/GameConstants';
import { UniversalLogger } from '../../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
export class GameOverState extends GameState {
  constructor(stateMachine: GameStateMachine) {
    super(stateMachine, GameConstants.STATE_GAME_OVER);
  }

  onEnter(): void {
    logger.info('Entering Game Over State', { state: this.stateName });
    this.calculateFinalScores();
    // Initialize game over UI and display results
  }

  onExit(): void {
    logger.info('Exiting Game Over State', { state: this.stateName });
    // Cleanup game over UI
  }

  update(): void {
    // Handle any animations or state updates in game over screen
  }

  private calculateFinalScores(): void {
    const stateData = this.stateMachine.getStateData();
    logger.debug('Calculating final scores', {
      state: this.stateName,
      moveHistory: stateData.moveHistory,
      currentScores: stateData.players.map(p => ({ id: p.id, score: p.score }))
    });
    // Add your score calculation logic here
    // This is where you would analyze the moveHistory and board state
    // to determine final scores
  }

  public getWinner(): { id: string; name: string; score: number } {
    const stateData = this.stateMachine.getStateData();
    const winner = stateData.players.reduce((highest, current) => {
      return current.score > highest.score ? current : highest;
    });

    logger.info('Winner determined', {
      state: this.stateName,
      winner,
      allScores: stateData.players.map(p => ({ id: p.id, score: p.score }))
    });

    return winner;
  }

  public startNewGame(): void {
    logger.info('Starting new game', { state: this.stateName });
    
    // Get final state for logging
    const finalState = this.stateMachine.getStateData();
    logger.debug('Final game state before reset', { 
      state: this.stateName,
      finalState 
    });

    // Reset the game state and transition to setup
    this.stateMachine.updateStateData({
      players: [],
      currentPlayerId: '',
      board: [],
      moveHistory: []
    });

    this.stateMachine.transitionTo(GameConstants.STATE_SETUP);
  }

  public getFinalScores(): Array<{ id: string; name: string; score: number }> {
    const stateData = this.stateMachine.getStateData();
    const sortedScores = [...stateData.players].sort((a, b) => b.score - a.score);
    
    logger.info('Final scores calculated', {
      state: this.stateName,
      scores: sortedScores.map(p => ({ id: p.id, score: p.score }))
    });

    return sortedScores;
  }
}

================
File: src/services/stateMachine/states/GameState.ts
================
import { GameStateMachine } from '../GameStateMachine';
import { UniversalLogger } from '../../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
export abstract class GameState {
  protected stateMachine: GameStateMachine;
  protected stateName: string;

  constructor(stateMachine: GameStateMachine, stateName: string) {
    this.stateMachine = stateMachine;
    this.stateName = stateName;
    logger.debug(`${stateName} state initialized`);
  }

  public getName(): string {
    return this.stateName;
  }

  abstract onEnter(): void;
  abstract onExit(): void;
  abstract update(): void;
}

================
File: src/services/stateMachine/states/PlayingState.ts
================
import { GameState } from './GameState';
import { GameStateMachine } from '../GameStateMachine';
import { ActionManager } from '../../ActionManager';
import { ActionType } from '../../strategies/ActionStrategyContext';
import { Position, BoardObject } from '../../BoardStateManager';
import { boardState } from '../../BoardStateManager';
import { GameConstants } from '../../../constants/GameConstants';
import { UniversalLogger } from '../../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
interface Move {
  playerId: string;
  action: string;
  position: Position;
  value?: number;
  timestamp: number;
}

export class PlayingState extends GameState {
  private actionManager: ActionManager;

  constructor(stateMachine: GameStateMachine) {
    super(stateMachine, GameConstants.STATE_PLAYING);
    this.actionManager = ActionManager.getInstance();
    logger.info('Playing state initialized');
  }

  onEnter(): void {
    logger.info('Entering playing state', { state: this.stateName });
    const stateData = this.stateMachine.getStateData();
    
    // Initialize board state with current game state
    boardState.clear();
    
    // Add cubes to board state
    if (stateData.board && Array.isArray(stateData.board)) {
      stateData.board.forEach((cube: any) => {
        if (cube && cube.position) {
          const pos = Array.isArray(cube.position)
            ? { x: cube.position[0], y: cube.position[1], z: cube.position[2] }
            : cube.position;
          
          boardState.updatePosition(pos.x, pos.z, {
            type: GameConstants.OBJECT_TYPE_CUBE,
            height: pos.y,
            id: cube.id
          });
          
          // logger.info('Added cube to board state', { 
          //   cube, 
          //   position: pos,
          //   bottomY: pos.y,
          //   topY: pos.y + 1
          // });
        }
      });
    } else {
      logger.warn('No board data or invalid board data in state', { 
        state: this.stateName,
        board: stateData.board 
      });
    }
    
    // Add players to board state
    if (stateData.players && Array.isArray(stateData.players)) {
      stateData.players.forEach((player: any) => {
        if (player && player.position) {
          const pos = Array.isArray(player.position)
            ? { x: player.position[0], y: player.position[1], z: player.position[2] }
            : player.position;
          
          boardState.updatePosition(pos.x, pos.z, {
            type: GameConstants.OBJECT_TYPE_PLAYER,
            height: pos.y,
            id: player.id.toString(),
            color: player.color
          });
          
          logger.info('Added player to board state', { 
            player, 
            position: pos,
            bottomY: pos.y,
            topY: pos.y + 1
          });
        }
      });
    } else {
      logger.warn('No players data or invalid players data in state', { 
        state: this.stateName,
        players: stateData.players 
      });
    }

    logger.info('Board state initialized', { stateData });
  }

  onExit(): void {
    logger.info('Exiting playing state', { state: this.stateName });
    this.actionManager.clearAction();
    boardState.clear();
  }

  selectAction(
    actionType: ActionType, 
    playerPos: number[] | Position, 
    particlesEnabled: boolean
  ): void {
    logger.info('Action selected', { 
      state: this.stateName,
      actionType, 
      playerPos,
      particlesEnabled
    });
    
    const stateData = this.stateMachine.getStateData();
    if (!stateData) {
      logger.error('No state data available', { state: this.stateName });
      return;
    }

    const currentPlayer = stateData.players.find(
      p => p.id.toString() === stateData.currentPlayerId
    );
    
    if (!currentPlayer) {
      logger.error('Current player not found', { 
        state: this.stateName,
        currentPlayerId: stateData.currentPlayerId 
      });
      return;
    }

    const position: Position = Array.isArray(playerPos) 
      ? { x: playerPos[0], y: playerPos[1], z: playerPos[2] }
      : playerPos;

    this.actionManager.startAction(
      actionType,
      position,
      currentPlayer.color,
      particlesEnabled
    );

    logger.info('Action selected in state machine', {
      actionType,
      playerId: currentPlayer.id,
      position: position,
      color: currentPlayer.color,
      particles: particlesEnabled
    });
  }

  handleMove(targetPos: Position): void {
    const currentAction = this.actionManager.getCurrentAction();
    
    if (currentAction.type !== 'move') {
      logger.warn('Attempted move but current action is not move', { 
        state: this.stateName,
        currentAction 
      });
      return;
    }

    if (!this.actionManager.isValidActionPosition(targetPos)) {
      logger.warn('Invalid move position selected', { 
        state: this.stateName,
        targetPos 
      });
      return;
    }

    logger.info('Processing move action', { 
      state: this.stateName,
      targetPos 
    });
    this.actionManager.setProcessing(true);

    // Update state data with new position
    const stateData = this.stateMachine.getStateData();
    if (stateData && stateData.currentPlayerId) {
      const playerIndex = stateData.players.findIndex(
        (p: any) => p.id.toString() === stateData.currentPlayerId
      );

      if (playerIndex !== -1) {
        const oldPosition = stateData.players[playerIndex].position;
        
        // Remove player from old position in board state
        if (oldPosition) {
          boardState.removeObject(
            oldPosition[0],
            oldPosition[2],
            stateData.currentPlayerId
          );
        }

        // Update player position in state data
        stateData.players[playerIndex].position = [targetPos.x, targetPos.y, targetPos.z];
        
        // Update player position in board state
        boardState.updatePosition(targetPos.x, targetPos.z, {
          type: GameConstants.OBJECT_TYPE_PLAYER,
          height: targetPos.y,
          id: stateData.currentPlayerId,
          color: stateData.players[playerIndex].color
        });

        this.stateMachine.updateStateData(stateData);
        logger.info('Player position updated', {
          state: this.stateName,
          playerId: stateData.currentPlayerId,
          oldPosition,
          newPosition: targetPos
        });
      }
    }

    this.actionManager.setProcessing(false);
    this.actionManager.clearAction();
  }

  handleBuild(targetPos: Position): void {
    const currentAction = this.actionManager.getCurrentAction();
    
    if (currentAction.type !== 'build') {
      logger.warn('Attempted build but current action is not build', { 
        state: this.stateName,
        currentAction 
      });
      return;
    }

    if (!this.actionManager.isValidActionPosition(targetPos)) {
      logger.warn('Invalid build position selected', { 
        state: this.stateName,
        targetPos 
      });
      return;
    }

    logger.info('Processing build action', { 
      state: this.stateName,
      targetPos 
    });
    this.actionManager.setProcessing(true);

    // Update state data with new cube
    const stateData = this.stateMachine.getStateData();
    if (stateData) {
      if (!stateData.board) {
        stateData.board = [];
      }

      const newCubeId = `cube-${stateData.board.length}`;
      
      // Add cube to state data
      stateData.board.push({
        id: newCubeId,
        position: [targetPos.x, targetPos.y, targetPos.z]
      });

      // Add cube to board state
      boardState.updatePosition(targetPos.x, targetPos.z, {
        type: GameConstants.OBJECT_TYPE_CUBE,
        height: targetPos.y,
        id: newCubeId
      });

      this.stateMachine.updateStateData(stateData);
      logger.info('New cube added to board', {
        state: this.stateName,
        cubeId: newCubeId,
        position: targetPos
      });
    }

    this.actionManager.setProcessing(false);
    this.actionManager.clearAction();
  }

  update(): void {
    // Handle any continuous updates if needed
  }

  public makeMove(move: Omit<Move, 'timestamp'>): void {
    logger.debug('Attempting move', { state: this.stateName, move });
    
    const stateData = this.stateMachine.getStateData();
    
    // Validate move
    if (!this.isValidMove(move)) {
      const error = 'Invalid move';
      logger.error(error, { 
        state: this.stateName,
        move, 
        currentPlayerId: stateData.currentPlayerId 
      });
      throw new Error(error);
    }

    // Record the move
    const fullMove: Move = {
      ...move,
      timestamp: Date.now()
    };

    logger.info('Move recorded', { state: this.stateName, move: fullMove });

    // Update game state
    this.stateMachine.updateStateData({
      moveHistory: [...stateData.moveHistory, fullMove]
    });

    // Check for game end conditions
    if (this.checkGameEnd()) {
      logger.info('Game end condition met', {
        state: this.stateName,
        moveHistory: stateData.moveHistory,
        lastMove: fullMove
      });
      this.stateMachine.transitionTo('gameOver');
      return;
    }

    // Move to next player
    this.nextTurn();
  }

  private isValidMove(move: Omit<Move, 'timestamp'>): boolean {
    const stateData = this.stateMachine.getStateData();
    
    // Verify it's the player's turn
    if (move.playerId !== stateData.currentPlayerId) {
      logger.warn('Move attempted by wrong player', {
        state: this.stateName,
        expectedPlayer: stateData.currentPlayerId,
        attemptingPlayer: move.playerId
      });
      return false;
    }

    // Add your move validation logic here
    return true;
  }

  private checkGameEnd(): boolean {
    const stateData = this.stateMachine.getStateData();
    logger.debug('Checking game end conditions', {
      state: this.stateName,
      moveCount: stateData.moveHistory.length,
      board: stateData.board
    });
    // Add your game end condition checks here
    return false;
  }

  private nextTurn(): void {
    const stateData = this.stateMachine.getStateData();
    const currentPlayerIndex = stateData.players.findIndex(
      player => player.id === stateData.currentPlayerId
    );
    const nextPlayerIndex = (currentPlayerIndex + 1) % stateData.players.length;
    const nextPlayer = stateData.players[nextPlayerIndex];
    
    logger.info('Moving to next player', {
      state: this.stateName,
      currentPlayer: stateData.players[currentPlayerIndex],
      nextPlayer
    });

    this.stateMachine.updateStateData({
      currentPlayerId: nextPlayer.id
    });
  }

  public getCurrentPlayer(): { id: string; name: string; score: number } {
    const stateData = this.stateMachine.getStateData();
    const currentPlayer = stateData.players.find(
      player => player.id === stateData.currentPlayerId
    );
    
    if (!currentPlayer) {
      const error = 'Current player not found';
      logger.error(error, {
        state: this.stateName,
        currentPlayerId: stateData.currentPlayerId,
        players: stateData.players
      });
      throw new Error(error);
    }

    return currentPlayer;
  }
}

================
File: src/services/stateMachine/states/SetupState.ts
================
import { GameState } from './GameState';
import { GameStateMachine, StateData } from '../GameStateMachine';
import { GameConstants } from '../../../constants/GameConstants';
import { UniversalLogger } from '../../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
export class SetupState extends GameState {
  constructor(stateMachine: GameStateMachine) {
    super(stateMachine, GameConstants.STATE_SETUP);
  }

  onEnter(): void {
    logger.info('Entering Setup State', { state: this.stateName });
    // Initialize game setup UI and listeners
  }

  onExit(): void {
    logger.info('Exiting Setup State', { state: this.stateName });
    // Cleanup setup UI and listeners
  }

  update(): void {
    // Handle ongoing setup state logic
  }

  public addPlayer(name: string): void {
    const stateData = this.stateMachine.getStateData();
    const newPlayer = {
      id: `player_${Date.now()}`,
      name,
      score: 0
    };

    logger.info('Adding new player', { state: this.stateName, player: newPlayer });

    this.stateMachine.updateStateData({
      players: [...stateData.players, newPlayer]
    });
  }

  public startGame(): void {
    const stateData = this.stateMachine.getStateData();
    if (stateData.players.length < 2) {
      const error = 'At least 2 players are required to start the game';
      logger.error(error, { 
        state: this.stateName, 
        playerCount: stateData.players.length 
      });
      throw new Error(error);
    }

    logger.info('Starting game', {
      state: this.stateName,
      players: stateData.players,
      firstPlayer: stateData.players[0]
    });

    const board = this.createInitialBoard();
    logger.debug('Initial board created', { 
      state: this.stateName, 
      board 
    });

    this.stateMachine.updateStateData({
      currentPlayerId: stateData.players[0].id,
      board
    });

    this.stateMachine.transitionTo('playing');
  }

  private createInitialBoard(): any {
    // Initialize your game board structure here
    return {
      // Add your board initialization logic
    };
  }
}

================
File: src/services/stateMachine/GameStateMachine.ts
================
import { GameState } from './states/GameState';
import { SetupState } from './states/SetupState';
import { PlayingState } from './states/PlayingState';
import { GameOverState } from './states/GameOverState';
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { Position } from '../BoardStateManager';
import { store } from '../../store';
import { updateGameState } from '../../store/gameReducer';
import { GameConstants } from '../../constants/GameConstants';

export interface Player {
  id: string;
  name: string;
  score: number;
  position: Position;
  color: string;
} 

export interface StateData {
  players: any[];
  currentPlayerId: string;
  board: any[];
  moveHistory: any[];
  timestamp: number;
}

export class GameStateMachine {
  private static instance: GameStateMachine;
  private currentState: GameState;
  private states: Map<string, GameState>;
  private stateData: StateData;
  private stateUpdateQueue: (() => void)[] = [];
  private isTransitioning: boolean = false;
  private isDispatchingToRedux: boolean = false;
  private pendingStateUpdate: { gameState?: string; stateData?: Partial<StateData> } | null = null;
  private updateTimeoutId: number | null = null;

  private constructor() {
    this.states = new Map();
    this.stateData = this.createInitialStateData();
    this.initializeStates();
    this.currentState = this.states.get(GameConstants.STATE_SETUP)!;
    logger.info('Game state machine initialized');
  }

  public static getInstance(): GameStateMachine {
    if (!GameStateMachine.instance) {
      GameStateMachine.instance = new GameStateMachine();
    }
    return GameStateMachine.instance;
  }

  private initializeStates(): void {
    this.states.set(GameConstants.STATE_SETUP, new SetupState(this));
    this.states.set(GameConstants.STATE_PLAYING, new PlayingState(this));
    this.states.set(GameConstants.STATE_GAME_OVER, new GameOverState(this));
  }

  private createInitialStateData(): StateData {
    return {
      players: [],
      currentPlayerId: '',
      board: [],
      moveHistory: [],
      timestamp: Date.now()
    };
  }

  public getCurrentState(): GameState | null {
    return this.currentState || null;
  }

  public setCurrentState(state: GameState): void {
    this.currentState = state;
  }

  public getStateData(): StateData {
    return { ...this.stateData };
  }

  private flushStateUpdate(): void {
    if (!this.pendingStateUpdate || this.isDispatchingToRedux) {
      return;
    }

    this.isDispatchingToRedux = true;
    try {
      store.dispatch(updateGameState(this.pendingStateUpdate));
      this.pendingStateUpdate = null;
    } finally {
      this.isDispatchingToRedux = false;
    }
  }

  private scheduleStateUpdate(): void {
    if (this.updateTimeoutId) {
      clearTimeout(this.updateTimeoutId);
    }

    this.updateTimeoutId = setTimeout(() => {
      this.flushStateUpdate();
      this.updateTimeoutId = null;
    }, 0);
  }

  public updateStateData(newData: Partial<StateData>): void {
    const oldData = { ...this.stateData };
    this.stateData = {
      ...this.stateData,
      ...newData,
      timestamp: Date.now()
    };

    logger.info('State data updated', {
      changes: Object.keys(newData),
      timestamp: this.stateData.timestamp
    });

    // Queue the state update
    this.pendingStateUpdate = {
      ...this.pendingStateUpdate,
      stateData: this.stateData
    };
    this.scheduleStateUpdate();
  }

  public transitionTo(stateName: string): void {
    if (this.isTransitioning) {
      this.stateUpdateQueue.push(() => this.transitionTo(stateName));
      logger.debug('State transition queued', { to: stateName });
      return;
    }

    this.isTransitioning = true;
    const nextState = this.states.get(stateName);

    if (!nextState) {
      logger.error('Invalid state transition requested', { to: stateName });
      this.isTransitioning = false;
      return;
    }

    const prevState = this.currentState;
    if (prevState) {
      logger.info('Exiting state', { from: prevState.getName() });
      prevState.onExit();
    }

    this.currentState = nextState;
    logger.info('Entering state', { to: stateName });
    nextState.onEnter();

    // Queue the state update
    this.pendingStateUpdate = {
      ...this.pendingStateUpdate,
      gameState: stateName,
      stateData: this.stateData
    };
    this.scheduleStateUpdate();

    logger.info('State transition complete', {
      from: prevState?.getName() || 'none',
      to: stateName,
      stateData: {
        players: this.stateData.players.length,
        currentPlayer: this.stateData.currentPlayerId,
        timestamp: this.stateData.timestamp
      }
    });

    this.isTransitioning = false;

    // Process any queued state updates
    if (this.stateUpdateQueue.length > 0) {
      const nextUpdate = this.stateUpdateQueue.shift();
      nextUpdate?.();
    }
  }

  public getCurrentStateName(): string {
    if (!this.currentState) {
      logger.warn('No current state set, defaulting to setup');
      return GameConstants.STATE_SETUP;
    }

    for (const [name, state] of this.states.entries()) {
      if (state === this.currentState) {
        return name;
      }
    }

    logger.error('Current state not found in states map');
    return GameConstants.STATE_SETUP; // Default to setup if state not found
  }

  private persistState(): void {
    const saveData = {
      currentState: this.getCurrentStateName(),
      stateData: this.stateData
    };
    localStorage.setItem(GameConstants.STORAGE_GAME_STATE, JSON.stringify(saveData));
    logger.debug('State persisted', saveData);
  }

  public loadPersistedState(): boolean {
    const savedState = localStorage.getItem(GameConstants.STORAGE_GAME_STATE);
    if (!savedState) {
      logger.info('No persisted state found');
      return false;
    }

    try {
      const { currentState, stateData } = JSON.parse(savedState);
      this.stateData = stateData;
      this.transitionTo(currentState);
      logger.info('Persisted state loaded', { currentState, stateData });
      return true;
    } catch (error) {
      logger.error('Error loading persisted state', { error });
      return false;
    }
  }

  public saveGame(saveName: string): void {
    const saveData = {
      currentState: this.getCurrentStateName(),
      stateData: this.stateData,
      timestamp: Date.now()
    };
    localStorage.setItem(`${GameConstants.STORAGE_SAVED_GAME_PREFIX}${saveName}`, JSON.stringify(saveData));
    logger.info('Game saved', { saveName, saveData });
  }

  public loadGame(saveName: string): boolean {
    const savedGame = localStorage.getItem(`${GameConstants.STORAGE_SAVED_GAME_PREFIX}${saveName}`);
    if (!savedGame) {
      logger.warn('Save game not found', { saveName });
      return false;
    }

    try {
      const { currentState, stateData } = JSON.parse(savedGame);
      this.stateData = stateData;
      this.transitionTo(currentState);
      logger.info('Game loaded', { saveName, currentState, stateData });
      return true;
    } catch (error) {
      logger.error('Error loading game', { saveName, error });
      return false;
    }
  }

  public listSavedGames(): Array<{ name: string; timestamp: number }> {
    const savedGames: Array<{ name: string; timestamp: number }> = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith(GameConstants.STORAGE_SAVED_GAME_PREFIX)) {
        try {
          const saveData = JSON.parse(localStorage.getItem(key)!);
          savedGames.push({
            name: key.replace(GameConstants.STORAGE_SAVED_GAME_PREFIX, ''),
            timestamp: saveData.timestamp
          });
        } catch (error) {
          logger.error('Error parsing saved game', { key, error });
        }
      }
    }
    logger.debug('Listed saved games', { savedGames });
    return savedGames;
  }
}

================
File: src/services/strategies/ActionStrategy.ts
================
import { Position } from '../BoardStateManager';
import { Scene } from 'three';
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { gameConfig } from '../../config/GameConfig';

export interface HighlightOptions {
  color: string;
  opacity?: number;
  particleEffect?: boolean;
}

export interface ActionValidationResult {
  isValid: boolean;
  reason?: string;
}

export interface IActionStrategy {
  getValidPositions(sourcePos: Position): Position[];
  validateAction(sourcePos: Position, targetPos: Position): ActionValidationResult;
  highlightValidPositions(positions: Position[], scene: Scene, options?: HighlightOptions): void;
  clearHighlights(scene: Scene): void;
}

export abstract class BaseActionStrategy implements IActionStrategy {
  protected constructor() {
    logger.info(`${this.constructor.name} strategy initialized`);
  }

  abstract getValidPositions(sourcePos: Position): Position[];
  abstract validateAction(sourcePos: Position, targetPos: Position): ActionValidationResult;
  abstract highlightValidPositions(positions: Position[], scene: Scene, options?: HighlightOptions): void;
  abstract clearHighlights(scene: Scene): void;

  protected isWithinBounds(pos: Position): boolean {
    const config = gameConfig.getConfig();
    return (
      pos.x >= -config.board.size/2 &&
      pos.x <= config.board.size/2 &&
      pos.z >= -config.board.size/2 &&
      pos.z <= config.board.size/2
    );
  }
}

================
File: src/services/strategies/ActionStrategyContext.ts
================
import { Position } from '../BoardStateManager';
import { Scene } from 'three';
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { BuildStrategy } from './BuildStrategy';
import { MoveStrategy } from './MoveStrategy';
import { GameConstants } from '../../constants/GameConstants';
import { BaseActionStrategy } from './ActionStrategy';

export type ActionType = typeof GameConstants.ACTION_NONE | 
                        typeof GameConstants.ACTION_BUILD | 
                        typeof GameConstants.ACTION_MOVE | 
                        typeof GameConstants.ACTION_ROLL;

export interface IActionStrategy {
  getValidPositions(sourcePosition: Position): Position[];
  validateAction(sourcePosition: Position, targetPosition: Position): { isValid: boolean; reason?: string };
  highlightValidPositions(positions: Position[], scene: Scene, options?: { color?: string; opacity?: number; particleEffect?: boolean }): void;
  clearHighlights(scene: Scene): void;
}

export class ActionStrategyContext {
  private static instance: ActionStrategyContext;
  private currentStrategy: BaseActionStrategy | null = null;
  private buildStrategy: BuildStrategy;
  private moveStrategy: MoveStrategy;

  private constructor() {
    this.buildStrategy = BuildStrategy.getInstance();
    this.moveStrategy = MoveStrategy.getInstance();
  }

  public static getInstance(): ActionStrategyContext {
    if (!ActionStrategyContext.instance) {
      ActionStrategyContext.instance = new ActionStrategyContext();
    }
    return ActionStrategyContext.instance;
  }

  public setStrategy(actionType: ActionType): void {
    logger.info('Setting action strategy', { actionType });

    if (actionType === GameConstants.ACTION_NONE) {
      this.currentStrategy = null;
      return;
    }

    if (actionType === GameConstants.ACTION_MOVE) {
      this.currentStrategy = this.moveStrategy;
    } else if (actionType === GameConstants.ACTION_BUILD) {
      this.currentStrategy = this.buildStrategy;
    } else {
      logger.warn('Unknown action type', { actionType });
      this.currentStrategy = null;
    }
  }

  public getCurrentStrategy(): BaseActionStrategy | null {
    return this.currentStrategy;
  }

  public getValidPositions(sourcePosition: Position): Position[] {
    if (!this.currentStrategy) {
      logger.warn('No strategy set for getting valid positions');
      return [];
    }
    return this.currentStrategy.getValidPositions(sourcePosition);
  }

  public validateAction(sourcePosition: Position, targetPosition: Position): { isValid: boolean; reason?: string } {
    if (!this.currentStrategy) {
      logger.warn('No strategy set for validating action');
      return { isValid: false, reason: 'No action selected' };
    }
    return this.currentStrategy.validateAction(sourcePosition, targetPosition);
  }

  public highlightValidPositions(
    positions: Position[],
    scene: Scene,
    options: { color?: string; opacity?: number; particleEffect?: boolean } = {}
  ): void {
    if (!this.currentStrategy) {
      logger.warn('No strategy set for highlighting positions');
      return;
    }
    this.currentStrategy.highlightValidPositions(positions, scene, {
      color: options.color || GameConstants.HIGHLIGHT_COLOR_DEFAULT,
      opacity: options.opacity || GameConstants.HIGHLIGHT_OPACITY,
      particleEffect: options.particleEffect
    });
  }

  public clearHighlights(scene: Scene): void {
    if (!this.currentStrategy) {
      logger.warn('No strategy set for clearing highlights');
      return;
    }
    this.currentStrategy.clearHighlights(scene);
  }
}

================
File: src/services/strategies/BuildStrategy.ts
================
import { Position, boardState, BoardObject } from '../BoardStateManager';
import { Scene, Mesh, BoxGeometry, MeshBasicMaterial, Color, Points, BufferGeometry, PointsMaterial, BufferAttribute, DoubleSide } from 'three';
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { gameConfig } from '../../config/GameConfig';
import { BaseActionStrategy, ActionValidationResult, HighlightOptions } from './ActionStrategy';
import { GameConstants } from '../../constants/GameConstants';
import { BuildValidator } from '../validators/BuildValidator';

interface CubeFace {
  position: Position;
  normal: { x: number; y: number; z: number };
  parentCube: { x: number; y: number; z: number };
}

export class BuildStrategy extends BaseActionStrategy {
  private static instance: BuildStrategy;
  private highlightedMeshes: Mesh[] = [];
  private lastCalculatedFaces: CubeFace[] = [];

  private constructor() {
    super();
    logger.info('BuildStrategy initialized');
  }

  public static getInstance(): BuildStrategy {
    if (!BuildStrategy.instance) {
      BuildStrategy.instance = new BuildStrategy();
    }
    return BuildStrategy.instance;
  }

  public getValidPositions(playerPos: Position): Position[] {
    logger.info('Getting valid build positions');
    
    // Use BuildValidator to get valid positions
    const validPositions = BuildValidator.getInstance().getValidBuildPositions(playerPos);
    
    logger.info('Valid build positions found', {
      count: validPositions.length,
      positions: validPositions
    });

    return validPositions;
  }

  private findAllExposedCubeFaces(): CubeFace[] {
    const exposedFaces: CubeFace[] = [];
    const occupiedPositions = new Set<string>(); // Track positions that are already occupied
    const playerPositions = new Set<string>(); // Track player positions

    // Get all entries from the board state
    const entries = Array.from((boardState as any).boardState.entries()) as [string, { objects: BoardObject[] }][];
    
    // First, collect all positions that have objects (cubes or players)
    entries.forEach(([key, value]) => {
      if (value.objects.length > 0) {
        // Check if there are any players at this position
        const hasPlayer = value.objects.some(obj => obj.type === GameConstants.OBJECT_TYPE_PLAYER);
        if (hasPlayer) {
          playerPositions.add(key);
        }
        occupiedPositions.add(key);
      }
    });

    // Process each position for top faces
    for (const [key, value] of entries) {
      // Get cubes at this position
      const cubes = value.objects
        .filter(obj => obj.type === GameConstants.OBJECT_TYPE_CUBE)
        .sort((a, b) => b.height - a.height); // Sort by height descending

      if (cubes.length > 0) {
        const topCube = cubes[0];
        const [x, z] = key.split(',').map(Number);

        // Check if there's a player at this height or above
        const hasPlayerAbove = Array.from(playerPositions).some(posKey => {
          const [px, pz] = posKey.split(',').map(Number);
          if (px === x && pz === z) {
            const playerObj = value.objects.find(obj => obj.type === GameConstants.OBJECT_TYPE_PLAYER);
            return playerObj && playerObj.height >= topCube.height;
          }
          return false;
        });

        // Skip if there's a player at this height or above
        if (hasPlayerAbove) {
          continue;
        }

        // Add face above the highest cube
        exposedFaces.push({
          position: {
            x: x,
            y: topCube.height + 1,
            z: z
          },
          normal: { x: 0, y: 1, z: 0 },
          parentCube: {
            x: x,
            y: topCube.height,
            z: z
          }
        });

        // Check adjacent ground positions
        const adjacentPositions = [
          { x: x + 1, z: z },
          { x: x - 1, z: z },
          { x: x, z: z + 1 },
          { x: x, z: z - 1 }
        ];

        for (const adjPos of adjacentPositions) {
          const adjKey = `${adjPos.x},${adjPos.z}`;
          
          // Skip if position is out of bounds
          if (!this.isWithinBounds({ x: adjPos.x, y: 0, z: adjPos.z })) {
            continue;
          }

          // Skip if position is already occupied
          if (occupiedPositions.has(adjKey)) {
            continue;
          }

          // Skip if there's a player at ground level
          if (playerPositions.has(adjKey)) {
            continue;
          }

          // Add ground-level face adjacent to cube
          exposedFaces.push({
            position: {
              x: adjPos.x,
              y: 0, // Ground level
              z: adjPos.z
            },
            normal: { x: 0, y: 1, z: 0 },
            parentCube: {
              x: x,
              y: 0,
              z: z
            }
          });

          // Mark this position as occupied so we don't add it again
          occupiedPositions.add(adjKey);
        }
      }
    }

    logger.info('Face detection complete:', {
      totalFaces: exposedFaces.length,
      faces: exposedFaces.map(face => ({
        position: face.position,
        normal: face.normal,
        parentCube: face.parentCube
      }))
    });

    return exposedFaces;
  }

  public validateAction(sourcePosition: Position, targetPosition: Position): ActionValidationResult {
    logger.info('Validating build position', { sourcePosition, targetPosition });

    // Use BuildValidator for validation
    const isValid = BuildValidator.getInstance().validateBuildPosition(sourcePosition, targetPosition);
    
    if (!isValid) {
      return { isValid: false, reason: 'Invalid build position' };
    }

    return { isValid: true };
  }

  public highlightValidPositions(
    positions: Position[],
    scene: Scene,
    options?: HighlightOptions
  ): void {
    logger.info('Highlighting valid build positions', {
      positions,
      options
    });

    this.clearHighlights(scene);

    const config = gameConfig.getConfig();
    // Log incoming options and config value
    logger.debug('[BuildStrategy] Received options:', options);
    logger.debug('[BuildStrategy] Config particleEffect default:', config.highlight.particleEffect);

    const highlightColor = options?.color || config.highlight.buildHighlightColor;
    const opacity = options?.opacity || 0.3;
    const showParticles = options?.particleEffect ?? config.highlight.particleEffect;
    // Log the calculated value
    logger.debug('[BuildStrategy] Calculated showParticles:', showParticles);

    // Create highlights for each position
    positions.forEach(position => {
      // Create a face for highlighting
      const face: CubeFace = {
        position: position,
        normal: { x: 0, y: 1, z: 0 }, // Always highlighting top face
        parentCube: {
          x: position.x,
          y: position.y - 1, // Parent cube is one level below
          z: position.z
        }
      };

      const highlight = this.createFaceHighlight(face, highlightColor, opacity);
      scene.add(highlight);
      this.highlightedMeshes.push(highlight);

      if (showParticles) {
        logger.info('[BuildStrategy] Adding particle effect because showParticles is true');
        this.addParticleEffect(position, scene, highlightColor);
      }
    });
  }

  private createFaceHighlight(
    face: CubeFace,
    color: string,
    opacity: number
  ): Mesh {
    // Create a thin plane geometry for the face
    const geometry = new BoxGeometry(
      Math.abs(face.normal.x) === 1 ? 0.02 : 1.02,
      Math.abs(face.normal.y) === 1 ? 0.02 : 1.02,
      Math.abs(face.normal.z) === 1 ? 0.02 : 1.02
    );

    const material = new MeshBasicMaterial({
      color: new Color(color),
      transparent: true,
      opacity: opacity,
      side: DoubleSide,
      depthWrite: false
    });

    const mesh = new Mesh(geometry, material);
    mesh.raycast = () => {};
    
    // Position the highlight slightly offset from the face
    const offset = 0.01; // Small offset to prevent z-fighting
    mesh.position.set(
      face.position.x - face.normal.x * offset,
      face.position.y - face.normal.y * offset,
      face.position.z - face.normal.z * offset
    );

    logger.debug('Created face highlight', {
      position: mesh.position,
      normal: face.normal,
      parentCube: face.parentCube
    });

    return mesh;
  }

  public clearHighlights(scene: Scene): void {
    logger.info('Clearing build highlights');
    
    this.highlightedMeshes.forEach(mesh => {
      scene.remove(mesh);
      mesh.geometry.dispose();
      (mesh.material as MeshBasicMaterial).dispose();
    });
    
    this.highlightedMeshes = [];
    // Clear stored faces when clearing highlights
    this.lastCalculatedFaces = [];
  }

  private addParticleEffect(
    position: Position,
    scene: Scene,
    color: string
  ): void {
    const particles = new Points(
      new BufferGeometry(),
      new PointsMaterial({
        color: new Color(color),
        size: 0.1,
        transparent: true,
        opacity: 0.6
      })
    );

    const particleCount = 8;
    const positions = new Float32Array(particleCount * 3);

    // Create particles in a column above the position
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = position.x + (Math.random() - 0.5) * 0.2;
      positions[i * 3 + 1] = position.y + (i / particleCount) * 1.5;
      positions[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.2;
    }

    particles.geometry.setAttribute(
      'position',
      new BufferAttribute(positions, 3)
    );

    scene.add(particles);
    this.highlightedMeshes.push(particles as unknown as Mesh);
  }
}

================
File: src/services/strategies/MoveStrategy.ts
================
import { Position, boardState } from '../BoardStateManager';
import { Scene, Mesh, BoxGeometry, MeshBasicMaterial, Color, Points, BufferGeometry, PointsMaterial, BufferAttribute, DoubleSide } from 'three';
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { gameConfig } from '../../config/GameConfig';
import { BaseActionStrategy, ActionValidationResult, HighlightOptions } from './ActionStrategy';
import { GameConstants } from '../../constants/GameConstants';

export class MoveStrategy extends BaseActionStrategy {
  private static instance: MoveStrategy;
  private highlightedMeshes: Mesh[] = [];

  private constructor() {
    super();
    logger.info('MoveStrategy initialized');
  }

  public static getInstance(): MoveStrategy {
    if (!MoveStrategy.instance) {
      MoveStrategy.instance = new MoveStrategy();
    }
    return MoveStrategy.instance; 
  }

  public getValidPositions(playerPos: Position): Position[] {
    logger.info('Getting valid move positions from', { playerPos });
    
    const validPositions: Position[] = [];
    const directions = gameConfig.getConfig().movement.allowedDirections;

    // Check each cardinal direction
    for (const direction of directions) {
      const targetX = Math.round((playerPos.x + direction.x) * 2) / 2;
      const targetZ = Math.round((playerPos.z + direction.z) * 2) / 2;

      // Check if target is within board bounds
      if (!this.isWithinBounds({ x: targetX, y: 0, z: targetZ })) {
        continue;
      }

      // Get all objects at target position
      const targetObjects = boardState.getObjectsAt(targetX, targetZ);
      const targetTopObject = boardState.getTopObject(targetX, targetZ);

      logger.info('Checking move position', {
        targetX,
        targetZ,
        targetObjects: targetObjects.map(obj => ({
          type: obj.type,
          height: obj.height,
          id: obj.id
        })),
        topObject: targetTopObject ? {
          type: targetTopObject.type,
          height: targetTopObject.height,
          id: targetTopObject.id
        } : null
      });

      // Cannot move if there's a player at this position
      const hasPlayer = targetObjects.some(obj => obj.type === GameConstants.OBJECT_TYPE_PLAYER);
      if (hasPlayer) {
        logger.info('Cannot move: Position occupied by player', { targetX, targetZ });
        continue;
      }

      // Get the height of the current position and target position
      const currentTopObject = boardState.getTopObject(playerPos.x, playerPos.z);
      const currentHeight = currentTopObject?.height || 0;

      // Calculate target height based on existing objects
      let targetHeight = 0;
      const cubesAtTarget = targetObjects.filter(obj => obj.type === GameConstants.OBJECT_TYPE_CUBE);
      if (cubesAtTarget.length > 0) {
        // Get the height of the topmost cube
        const topCube = cubesAtTarget.reduce((highest, cube) => 
          cube.height > highest.height ? cube : highest
        , cubesAtTarget[0]);
        targetHeight = topCube.height + 1;
      }

      const heightDiff = targetHeight - currentHeight;
      const config = gameConfig.getConfig();

      // Check height constraints for movement
      if (heightDiff > config.movement.maxClimbHeight) {
        logger.info('Cannot move: Height difference too large', {
          heightDiff,
          maxClimbHeight: config.movement.maxClimbHeight
        });
        continue;
      }

      if (config.movement.maxDescendHeight > 0 && 
          -heightDiff > config.movement.maxDescendHeight) {
        logger.info('Cannot move: Descent too steep', {
          heightDiff,
          maxDescendHeight: config.movement.maxDescendHeight
        });
        continue;
      }

      // If we reach here, the position is valid
      const validPosition: Position = {
        x: targetX,
        y: targetHeight,
        z: targetZ
      };

      validPositions.push(validPosition);
      logger.info('Valid move position found', { 
        validPosition,
        currentHeight,
        targetHeight,
        heightDiff,
        direction
      });
    }

    logger.info('Valid move positions complete', { 
      playerPos,
      validPositions,
      count: validPositions.length
    });

    return validPositions;
  }

  private getInvalidMoveReason(sourcePos: Position, targetPos: Position): string | null {
    // Check if target is within board bounds
    if (!this.isWithinBounds(targetPos)) {
      return 'Target position is out of bounds';
    }

    const config = gameConfig.getConfig();

    // Check if move is in an allowed direction
    const dx = targetPos.x - sourcePos.x;
    const dz = targetPos.z - sourcePos.z;
    const isValidDirection = config.movement.allowedDirections.some(
      dir => Math.abs(dx - dir.x) < 0.1 && Math.abs(dz - dir.z) < 0.1
    );
    if (!isValidDirection) {
      return 'Invalid move direction';
    }

    // Get top objects at source and target positions
    const sourceTopObject = boardState.getTopObject(sourcePos.x, sourcePos.z);
    const targetTopObject = boardState.getTopObject(targetPos.x, targetPos.z);

    const sourceHeight = sourceTopObject?.height || 0;
    const targetHeight = targetTopObject?.height || 0;
    const heightDiff = targetHeight - sourceHeight;

    // Check if climb height is within allowed range
    if (heightDiff > config.movement.maxClimbHeight) {
      return `Height difference ${heightDiff} exceeds max climb height ${config.movement.maxClimbHeight}`;
    }

    // Check if descend height is within allowed range (if configured)
    if (config.movement.maxDescendHeight > 0 && 
        -heightDiff > config.movement.maxDescendHeight) {
      return `Descent height ${-heightDiff} exceeds max descend height ${config.movement.maxDescendHeight}`;
    }

    // Check if target position is occupied by a player
    const targetObjects = boardState.getObjectsAt(targetPos.x, targetPos.z);
    if (targetObjects.some(obj => obj.type === GameConstants.OBJECT_TYPE_PLAYER)) {
      return 'Target position is occupied by a player';
    }

    return null;
  }

  public validateAction(sourcePosition: Position, targetPosition: Position): ActionValidationResult {
    logger.info('Validating move position', { sourcePosition, targetPosition });

    const reason = this.getInvalidMoveReason(sourcePosition, targetPosition);
    if (reason) {
      logger.warn('Invalid move position', { reason, sourcePosition, targetPosition });
      return { isValid: false, reason };
    }

    return { isValid: true };
  }

  public highlightValidPositions(
    positions: Position[],
    scene: Scene,
    options?: HighlightOptions
  ): void {
    logger.info('Highlighting valid move positions', {
      positions,
      options
    });

    this.clearHighlights(scene);

    const config = gameConfig.getConfig();
    // Log incoming options and config value
    logger.debug('[MoveStrategy] Received options:', options);
    logger.debug('[MoveStrategy] Config particleEffect default:', config.highlight.particleEffect);

    const highlightColor = options?.color || config.highlight.moveHighlightColor;
    const opacity = options?.opacity || 0.3;
    const showParticles = options?.particleEffect ?? config.highlight.particleEffect;
    // Log the calculated value
    logger.debug('[MoveStrategy] Calculated showParticles:', showParticles);

    positions.forEach(position => {
      const highlight = this.createHighlightMesh(position, highlightColor, opacity);
      scene.add(highlight);
      this.highlightedMeshes.push(highlight);

      if (showParticles) {
        logger.info('[MoveStrategy] Adding particle effect because showParticles is true');
        this.addParticleEffect(position, scene, highlightColor);
      }
    });
  }

  public clearHighlights(scene: Scene): void {
    logger.info('Clearing move highlights');
    
    this.highlightedMeshes.forEach(mesh => {
      scene.remove(mesh);
      mesh.geometry.dispose();
      (mesh.material as MeshBasicMaterial).dispose();
    });
    
    this.highlightedMeshes = [];
  }

  private createHighlightMesh(
    position: Position,
    color: string,
    opacity: number
  ): Mesh {
    // Create a plane geometry for the top face only
    const geometry = new BoxGeometry(1.02, 0.02, 1.02); // Very thin box to act as a plane
    const material = new MeshBasicMaterial({
      color: new Color(color),
      transparent: true,
      opacity: opacity,
      side: DoubleSide,
      depthWrite: false
    });

    const mesh = new Mesh(geometry, material);
    mesh.raycast = () => {};
    
    // Position the plane slightly above the surface
    mesh.position.set(
      position.x,
      position.y + 0.01, // Just slightly above the surface
      position.z
    );

    logger.info('Created move highlight mesh', {
      position: mesh.position,
      originalY: position.y,
      adjustedY: position.y + 0.01,
      color,
      opacity
    });

    return mesh;
  }

  private addParticleEffect(
    position: Position,
    scene: Scene,
    color: string
  ): void {
    const particles = new Points(
      new BufferGeometry(),
      new PointsMaterial({
        color: new Color(color),
        size: 0.1,
        transparent: true,
        opacity: 0.6
      })
    );

    const particleCount = 8;
    const positions = new Float32Array(particleCount * 3);

    // Create particles in a column above the position
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = position.x + (Math.random() - 0.5) * 0.2;
      positions[i * 3 + 1] = position.y + (i / particleCount) * 1.5;
      positions[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.2;
    }

    particles.geometry.setAttribute(
      'position',
      new BufferAttribute(positions, 3)
    );

    scene.add(particles);
    this.highlightedMeshes.push(particles as unknown as Mesh);
  }
}

================
File: src/services/utils/HeightCalculator.ts
================
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { Position, BoardObject } from '../BoardStateManager';
import { boardState } from '../BoardStateManager';

export class HeightCalculator {
  private static instance: HeightCalculator;

  private constructor() {
    logger.info('Height calculator initialized');
  }

  public static getInstance(): HeightCalculator {
    if (!HeightCalculator.instance) {
      HeightCalculator.instance = new HeightCalculator();
    }
    return HeightCalculator.instance;
  }

  /**
   * Calculates the height for a new cube at the given position
   */
  public calculateBuildHeight(x: number, z: number): number {
    const targetObjects = boardState.getObjectsAt(x, z);
    const targetTopObject = boardState.getTopObject(x, z);

    // If there's a cube, build on top of it (height + 1)
    // If it's ground, build at height 1
    return targetTopObject?.type === 'cube' ? targetTopObject.height + 1 : 1;
  }

  /**
   * Gets the expected height for building on top of existing cubes
   */
  public getExpectedHeight(x: number, z: number): number {
    const targetObjects = boardState.getObjectsAt(x, z);
    const cubes = targetObjects
      .filter(obj => obj.type === 'cube')
      .sort((a, b) => b.height - a.height);

    if (cubes.length === 0) {
      return 1; // Ground build
    }

    return cubes[0].height + 1; // Build on top of highest cube
  }

  /**
   * Checks if a position has a player at or above the given height
   */
  public hasPlayerAtHeight(x: number, z: number, height: number): boolean {
    const targetObjects = boardState.getObjectsAt(x, z);
    return targetObjects.some(obj => 
      obj.type === 'player' && obj.height >= height
    );
  }
}

================
File: src/services/validators/BuildPositionCalculator.ts
================
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { gameConfig } from '../../config/GameConfig';
import { boardState, Position } from '../BoardStateManager';
import { HeightCalculator } from '../utils/HeightCalculator';

export class BuildPositionCalculator {
  private static instance: BuildPositionCalculator;
  private heightCalculator: HeightCalculator;

  private constructor() {
    this.heightCalculator = HeightCalculator.getInstance();
    logger.info('Build position calculator initialized');
  }

  public static getInstance(): BuildPositionCalculator {
    if (!BuildPositionCalculator.instance) {
      BuildPositionCalculator.instance = new BuildPositionCalculator();
    }
    return BuildPositionCalculator.instance;
  }

  /**
   * Gets all valid positions where a cube can be built from the player's position
   */
  public getValidBuildPositions(playerPos: Position): Position[] {
    logger.info('Getting valid build positions from', { playerPos });
    
    const validPositions: Position[] = [];
    const directions = gameConfig.getConfig().movement.allowedDirections;

    // Check each cardinal direction
    for (const direction of directions) {
      const targetX = Math.round((playerPos.x + direction.x) * 2) / 2;
      const targetZ = Math.round((playerPos.z + direction.z) * 2) / 2;

      // Check if target is within board bounds
      if (!this.isWithinBounds({ x: targetX, y: 0, z: targetZ })) {
        continue;
      }

      // Calculate the height for the new cube
      const newCubeHeight = this.heightCalculator.calculateBuildHeight(targetX, targetZ);

      // Check for players at or above the target height
      if (this.heightCalculator.hasPlayerAtHeight(targetX, targetZ, newCubeHeight)) {
        logger.info('Cannot build: Player at or above target height', { 
          targetX, 
          targetZ, 
          newCubeHeight 
        });
        continue;
      }

      // Check if height difference is within build limits
      const config = gameConfig.getConfig();
      if (config.build.maxBuildHeight > 0 && 
          newCubeHeight > config.build.maxBuildHeight) {
        logger.info('Cannot build: Exceeds maximum height', {
          newCubeHeight,
          maxBuildHeight: config.build.maxBuildHeight
        });
        continue;
      }

      // If we reach here, we can build at this position
      const validPosition: Position = {
        x: targetX,
        y: newCubeHeight,
        z: targetZ
      };

      validPositions.push(validPosition);
      logger.info('Valid build position found', { 
        validPosition,
        newCubeHeight,
        direction
      });
    }

    logger.info('Valid build positions complete', { 
      playerPos,
      validPositions,
      count: validPositions.length
    });

    return validPositions;
  }

  private isWithinBounds(pos: Position): boolean {
    const config = gameConfig.getConfig();
    return (
      pos.x >= -config.board.size/2 &&
      pos.x <= config.board.size/2 &&
      pos.z >= -config.board.size/2 &&
      pos.z <= config.board.size/2
    );
  }
}

================
File: src/services/validators/BuildValidator.ts
================
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { gameConfig } from '../../config/GameConfig';
import { boardState, Position } from '../BoardStateManager';
import { HeightCalculator } from '../utils/HeightCalculator';
import { BuildPositionCalculator } from './BuildPositionCalculator';

export interface BuildValidationResult {
  isValid: boolean;
  reason?: string;
}
 
export class BuildValidator {
  private static instance: BuildValidator;
  private heightCalculator: HeightCalculator;
  private positionCalculator: BuildPositionCalculator;

  private constructor() {
    this.heightCalculator = HeightCalculator.getInstance();
    this.positionCalculator = BuildPositionCalculator.getInstance();
    logger.info('Build validator initialized');
  }

  public static getInstance(): BuildValidator {
    if (!BuildValidator.instance) {
      BuildValidator.instance = new BuildValidator();
    }
    return BuildValidator.instance;
  }

  /**
   * Gets all valid positions where a cube can be built from the player's position
   */
  public getValidBuildPositions(playerPos: Position): Position[] {
    return this.positionCalculator.getValidBuildPositions(playerPos);
  }

  /**
   * Validates if a build action at the target position is valid
   */
  public validateBuild(
    playerPos: Position,
    targetPos: Position,
    boardState: Map<string, Position>,
    playerPositions: Map<string, Position>
  ): BuildValidationResult {
    logger.info('Validating build action', {
      playerPos,
      targetPos
    });

    // Check if target position is occupied by a player
    if (this.isPositionOccupied(targetPos, playerPositions)) {
      return {
        isValid: false,
        reason: 'Cannot build where a player is standing'
      };
    }

    // Check if the build height is valid
    const currentHeight = this.getHeightAtPosition(targetPos, boardState);
    const config = gameConfig.getConfig();
    
    if (config.build.maxBuildHeight > 0 && 
        currentHeight >= config.build.maxBuildHeight) {
      return {
        isValid: false,
        reason: 'Maximum build height exceeded'
      };
    }

    return { isValid: true };
  }

  /**
   * Validates if a build at target position is valid from source position
   */
  public validateBuildPosition(sourcePos: Position, targetPos: Position): boolean {
    logger.info('Validating build position', { sourcePos, targetPos });

    // Check if target is within board bounds
    if (!this.positionCalculator['isWithinBounds'](targetPos)) {
      logger.warn('Invalid build position: Out of bounds', { targetPos });
      return false;
    }

    // Get objects at the target position
    const targetObjects = boardState.getObjectsAt(targetPos.x, targetPos.z);
    
    // Check for players at or above the target height
    if (this.heightCalculator.hasPlayerAtHeight(targetPos.x, targetPos.z, targetPos.y)) {
      logger.warn('Invalid build position: Player at or above target height', { targetPos });
      return false;
    }

    // Get cubes at this position, sorted by height
    const cubes = targetObjects
      .filter(obj => obj.type === 'cube')
      .sort((a, b) => b.height - a.height);

    // If building on ground (no cubes)
    if (cubes.length === 0) {
      // Check if there are adjacent cubes
      const adjacentPositions = [
        { x: targetPos.x + 1, z: targetPos.z },
        { x: targetPos.x - 1, z: targetPos.z },
        { x: targetPos.x, z: targetPos.z + 1 },
        { x: targetPos.x, z: targetPos.z - 1 }
      ];

      const hasAdjacentCube = adjacentPositions.some(pos => {
        const adjObjects = boardState.getObjectsAt(pos.x, pos.z);
        return adjObjects.some(obj => obj.type === 'cube');
      });

      if (!hasAdjacentCube) {
        logger.warn('Invalid build position: No adjacent cubes for ground build', { targetPos });
        return false;
      }

      // For ground builds, height must be 1
      if (targetPos.y !== 1) {
        logger.warn('Invalid build position: Ground builds must be at height 1', { targetPos });
        return false;
      }

      return true;
    }

    // Building on top of existing cubes
    const expectedHeight = this.heightCalculator.getExpectedHeight(targetPos.x, targetPos.z);

    if (targetPos.y !== expectedHeight) {
      logger.warn('Invalid build position: Must build at height one above highest cube', { 
        targetPos, 
        expectedHeight 
      });
      return false;
    }

    return true;
  }

  private isPositionOccupied(
    position: Position,
    playerPositions: Map<string, Position>
  ): boolean {
    return Array.from(playerPositions.values()).some(
      pos => pos.x === position.x && pos.z === position.z
    );
  }

  private getHeightAtPosition(
    pos: Position,
    boardState: Map<string, Position>
  ): number {
    return Array.from(boardState.values())
      .filter(cube => cube.x === pos.x && cube.z === pos.z)
      .reduce((maxHeight, cube) => Math.max(maxHeight, cube.y), 0);
  }
}

================
File: src/services/validators/MovementValidator.ts
================
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { gameConfig } from '../../config/GameConfig';
import { boardState, Position, BoardObject } from '../BoardStateManager';

export interface MoveValidationResult {
  isValid: boolean;
  reason?: string;
}

export class MovementValidator {
  private static instance: MovementValidator;

  private constructor() {
    logger.info('Movement validator initialized');
  }

  public static getInstance(): MovementValidator {
    if (!MovementValidator.instance) {
      MovementValidator.instance = new MovementValidator();
    }
    return MovementValidator.instance;
  }

  /**
   * Gets all valid moves for a player at the given position
   */
  public getValidMoves(playerPos: Position): Position[] {
    logger.info('Getting valid moves from position', { playerPos });
    
    const validMoves: Position[] = [];
    const directions = gameConfig.getConfig().movement.allowedDirections;
    
    // Get the source position's top object (where the player is)
    const sourceObjects = boardState.getObjectsAt(playerPos.x, playerPos.z);
    const sourceTopObject = boardState.getTopObject(playerPos.x, playerPos.z);
    const sourceHeight = sourceTopObject?.height || 0;

    logger.info('Source position details', { 
      sourceObjects,
      sourceTopObject,
      sourceHeight,
      playerPos 
    });

    // Check each cardinal direction
    for (const direction of directions) {
      const targetX = Math.round((playerPos.x + direction.x) * 2) / 2;
      const targetZ = Math.round((playerPos.z + direction.z) * 2) / 2;

      logger.info('Checking direction', {
        direction,
        targetX,
        targetZ,
        originalX: playerPos.x + direction.x,
        originalZ: playerPos.z + direction.z
      });

      // Check if target is within board bounds
      if (!this.isWithinBounds({ x: targetX, y: 0, z: targetZ })) {
        logger.info('Position out of bounds', { targetX, targetZ });
        continue;
      }

      // Get all objects and top object at target position
      const targetObjects = boardState.getObjectsAt(targetX, targetZ);
      const targetTopObject = boardState.getTopObject(targetX, targetZ);
      
      // If there's a cube, the player will be on top of it
      const hasCube = targetObjects.some(obj => obj.type === 'cube');
      const targetHeight = hasCube ? 1 : 0; // If there's a cube, player will be at height 1

      logger.info('Target position details', {
        targetX,
        targetZ,
        targetObjects,
        targetTopObject,
        hasCube,
        targetHeight,
        heightDifference: targetHeight - sourceHeight
      });

      // Check if target position is occupied by a player
      const hasPlayer = targetObjects.some(obj => obj.type === 'player');

      if (hasPlayer) {
        logger.info('Target position occupied by player', { 
          targetX, 
          targetZ,
          objects: targetObjects 
        });
        continue;
      }

      // Calculate height difference
      const heightDiff = targetHeight - sourceHeight;
      const config = gameConfig.getConfig();

      // Check if height difference is within allowed range
      if (heightDiff > config.movement.maxClimbHeight) {
        logger.info('Height difference too large to climb', { 
          sourceHeight,
          targetHeight,
          heightDiff,
          maxClimbHeight: config.movement.maxClimbHeight 
        });
        continue;
      }

      if (config.movement.maxDescendHeight > 0 && 
          -heightDiff > config.movement.maxDescendHeight) {
        logger.info('Height difference too large to descend', { 
          sourceHeight,
          targetHeight,
          heightDiff,
          maxDescendHeight: config.movement.maxDescendHeight 
        });
        continue;
      }

      // If we reach here, the move is valid
      const validMove: Position = {
        x: targetX,
        y: targetHeight, // Player will be at height 1 if moving onto a cube
        z: targetZ
      };

      validMoves.push(validMove);
      logger.info('Valid move found', { 
        validMove,
        sourceHeight,
        targetHeight,
        heightDiff,
        hasCube 
      });
    }

    logger.info('Valid moves calculation complete', { 
      playerPos,
      validMoves,
      count: validMoves.length
    });

    return validMoves;
  }

  /**
   * Validates if a move from source to target position is valid
   */
  public validateMove(sourcePos: Position, targetPos: Position): boolean {
    logger.info('Validating move', { sourcePos, targetPos });

    const reason = this.getInvalidMoveReason(sourcePos, targetPos);
    if (reason) {
      logger.warn('Invalid move', { reason, sourcePos, targetPos });
      return false;
    }

    return true;
  }

  private getInvalidMoveReason(sourcePos: Position, targetPos: Position): string | null {
    // Check if target is within board bounds
    if (!this.isWithinBounds(targetPos)) {
      return 'Target position is out of bounds';
    }

    // Get top objects at source and target positions
    const sourceTopObject = boardState.getTopObject(sourcePos.x, sourcePos.z);
    const targetTopObject = boardState.getTopObject(targetPos.x, targetPos.z);

    const sourceHeight = sourceTopObject?.height || 0;
    const targetHeight = targetTopObject?.height || 0;
    const heightDiff = targetHeight - sourceHeight;

    const config = gameConfig.getConfig();
    // Check if height difference is within allowed range
    if (heightDiff > config.movement.maxClimbHeight) {
      return `Height difference ${heightDiff} exceeds max climb height ${config.movement.maxClimbHeight}`;
    }
    if (-heightDiff > config.movement.maxDescendHeight) {
      return `Height difference ${-heightDiff} exceeds max descend height ${config.movement.maxDescendHeight}`;
    }

    // Check if target position is occupied by another player
    const targetObjects = boardState.getObjectsAt(targetPos.x, targetPos.z);
    if (targetObjects.some(obj => obj.type === 'player')) {
      return 'Target position is occupied by another player';
    }

    return null;
  }

  private isWithinBounds(pos: Position): boolean {
    const config = gameConfig.getConfig();
    const result = (
      pos.x >= -config.board.size/2 &&
      pos.x <= config.board.size/2 &&
      pos.z >= -config.board.size/2 &&
      pos.z <= config.board.size/2
    );

    logger.info('Bounds check', { 
      position: pos, 
      boardSize: config.board.size,
      isWithinBounds: result 
    });

    return result;
  }
}

================
File: src/services/ActionHandler.ts
================
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { GameStateManager, Player, Cube } from './GameStateManager';
import { BuildValidator } from './validators/BuildValidator';
import { MagneticPhysics } from './physics';
import { GameConstants } from '../constants/GameConstants';
import { Position } from './BoardStateManager';

export class ActionHandler {
  private static instance: ActionHandler;
  private stateManager: GameStateManager;
  private buildValidator: BuildValidator;
  private physics: MagneticPhysics;

  private constructor() {
    this.stateManager = GameStateManager.getInstance();
    this.buildValidator = BuildValidator.getInstance();
    this.physics = MagneticPhysics.getInstance();
    logger.info('ActionHandler initialized');
  }

  public static getInstance(): ActionHandler {
    if (!ActionHandler.instance) {
      ActionHandler.instance = new ActionHandler();
    }
    return ActionHandler.instance;
  }

  public build(playerId: number, position: number[]): boolean {
    logger.info('Attempting build action', { playerId, position });

    // 1. Phase check
    if (this.stateManager.getGamePhase() !== GameConstants.STATE_PLAYING) {
      logger.warn('Build action attempted in wrong phase', {
        currentPhase: this.stateManager.getGamePhase(),
        requiredPhase: GameConstants.STATE_PLAYING
      });
      return false;
    }

    // 2. Player check
    if (playerId !== this.stateManager.getCurrentPlayer()) {
      logger.warn('Build action attempted by wrong player', {
        currentPlayer: this.stateManager.getCurrentPlayer(),
        attemptingPlayer: playerId
      });
      return false;
    }

    // 3. Get current player
    const player = this.stateManager.getPlayer(playerId);
    if (!player) {
      logger.error('Player not found', { playerId });
      return false;
    }

    // 4. Convert position to Position type for BuildValidator
    const buildPosition: Position = {
      x: Math.round(position[0] * 2) / 2,
      y: Math.round(position[1]),
      z: Math.round(position[2] * 2) / 2
    };

    const playerPosition: Position = {
      x: player.position[0],
      y: player.position[1],
      z: player.position[2]
    };

    // 5. Validate build using BuildValidator
    const validationResult = this.buildValidator.validateBuild(
      playerPosition,
      buildPosition,
      this.convertCubesToPositions(),
      this.convertPlayersToPositions()
    );

    if (!validationResult.isValid) {
      logger.warn('Invalid build position', {
        position: buildPosition,
        reason: validationResult.reason
      });
      return false;
    }

    // 6. Create and add cube
    const cubeId = `cube-${Date.now()}`;
    const newCube: Cube = {
      id: cubeId,
      position: [buildPosition.x, buildPosition.y, buildPosition.z],
      owner: playerId,
      size: 1
    };

    this.stateManager.addCube(newCube);
    this.physics.addCube(cubeId, newCube.position);

    // 7. Mark build action as used
    player.canBuild = false;

    logger.info('Build action successful', {
      cubeId,
      position: newCube.position,
      playerId
    });

    return true;
  }

  public move(playerId: number, newPosition: number[]): boolean {
    logger.info('Attempting move action', { playerId, newPosition });

    // 1. Phase check
    if (this.stateManager.getGamePhase() !== GameConstants.STATE_PLAYING) {
      logger.warn('Move action attempted in wrong phase', {
        currentPhase: this.stateManager.getGamePhase(),
        requiredPhase: GameConstants.STATE_PLAYING
      });
      return false;
    }

    // 2. Player check
    if (playerId !== this.stateManager.getCurrentPlayer()) {
      logger.warn('Move action attempted by wrong player', {
        currentPlayer: this.stateManager.getCurrentPlayer(),
        attemptingPlayer: playerId
      });
      return false;
    }

    // 3. Get current player
    const player = this.stateManager.getPlayer(playerId);
    if (!player) {
      logger.error('Player not found', { playerId });
      return false;
    }

    // 4. Validate move
    if (!this.isValidMove(player.position, newPosition)) {
      logger.warn('Invalid move position', {
        from: player.position,
        to: newPosition
      });
      return false;
    }

    // 5. Update player position
    const oldPosition = [...player.position];
    player.position = newPosition;
    player.canMove = false;

    // 6. Update physics - no need to update physics for player position
    // as the physics system only tracks cubes

    logger.info('Move action successful', {
      playerId,
      from: oldPosition,
      to: newPosition
    });

    return true;
  }

  private isValidMove(from: number[], to: number[]): boolean {
    // Check if move is within one space in any direction
    const dx = Math.abs(to[0] - from[0]);
    const dy = Math.abs(to[1] - from[1]);
    const dz = Math.abs(to[2] - from[2]);

    if (dx > 1 || dy > 1 || dz > 1) {
      logger.info('Move validation failed: distance too far', { dx, dy, dz });
      return false;
    }

    // Check if destination is occupied
    for (const player of this.stateManager.getPlayers().values()) {
      if (player.position[0] === to[0] &&
          player.position[1] === to[1] &&
          player.position[2] === to[2]) {
        logger.info('Move validation failed: destination occupied', {
          byPlayer: player.id,
          position: to
        });
        return false;
      }
    }

    return true;
  }

  private convertCubesToPositions(): Map<string, Position> {
    const positions = new Map<string, Position>();
    for (const [id, cube] of this.stateManager.getCubes()) {
      positions.set(id, {
        x: cube.position[0],
        y: cube.position[1],
        z: cube.position[2]
      });
    }
    return positions;
  }

  private convertPlayersToPositions(): Map<string, Position> {
    const positions = new Map<string, Position>();
    for (const [id, player] of this.stateManager.getPlayers()) {
      positions.set(id.toString(), {
        x: player.position[0],
        y: player.position[1],
        z: player.position[2]
      });
    }
    return positions;
  }
}

================
File: src/services/ActionManager.ts
================
import { Scene } from 'three';
import { Position } from './BoardStateManager';
import { ActionStrategyContext, ActionType } from './strategies/ActionStrategyContext';
import { GameConstants } from '../constants/GameConstants';
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
export interface ActionState {
  type: ActionType;
  isProcessing: boolean;
  validPositions: Position[];
  sourcePosition?: Position;
}

export class ActionManager {
  private static instance: ActionManager;
  private currentAction: ActionState;
  private scene: Scene | null = null;
  private readonly strategyContext: ActionStrategyContext;
  private sceneInitializationQueue: (() => void)[] = [];

  private constructor() {
    this.currentAction = {
      type: GameConstants.ACTION_NONE,
      isProcessing: false,
      validPositions: []
    };

    this.strategyContext = ActionStrategyContext.getInstance();
    logger.info('Action manager initialized');
  }

  public static getInstance(): ActionManager {
    if (!ActionManager.instance) {
      ActionManager.instance = new ActionManager();
    }
    return ActionManager.instance;
  }

  public setScene(scene: Scene | null): void {
    this.scene = scene;
    if (scene) {
      logger.info('Scene set in action manager', { sceneId: scene.id });
      // Process any queued operations
      while (this.sceneInitializationQueue.length > 0) {
        const operation = this.sceneInitializationQueue.shift();
        operation?.();
      }
    }
  }

  public getCurrentAction(): ActionState {
    return { ...this.currentAction };
  }

  public setProcessing(isProcessing: boolean): void {
    this.currentAction.isProcessing = isProcessing;
    logger.info('Action processing state updated', { isProcessing });
  }

  public clearAction(): void {
    if (!this.scene) {
      // Queue the clear operation for when scene is available
      this.sceneInitializationQueue.push(() => this.clearAction());
      logger.debug('Clear action queued: waiting for scene initialization');
      return;
    }

    this.strategyContext.clearHighlights(this.scene);
    this.strategyContext.setStrategy(GameConstants.ACTION_NONE);

    this.currentAction = {
      type: GameConstants.ACTION_NONE,
      isProcessing: false,
      validPositions: []
    };

    logger.info('Action cleared', { sceneId: this.scene.id });
  }

  /**
   * Starts a new action of the specified type
   * @param actionType Type of action to start
   * @param sourcePosition Current player position
   * @param playerColor Color to use for highlights
   * @param particlesEnabled Whether particle effects should be shown for highlights
   */
  public startAction(
    actionType: ActionType,
    sourcePosition: Position,
    playerColor: string = GameConstants.HIGHLIGHT_COLOR_DEFAULT,
    particlesEnabled: boolean
  ): void {
    if (!this.scene) {
      logger.error('Cannot start action: scene not set');
      return;
    }

    logger.info('Starting action', { actionType, sourcePosition, playerColor, particlesEnabled });
    this.clearAction();
    if (actionType === GameConstants.ACTION_NONE) return;

    this.strategyContext.setStrategy(actionType);
    let validPositions = this.strategyContext.getValidPositions(sourcePosition);
    
    // Filter out positions that are invalid according to the current game state
    validPositions = validPositions.filter(pos => {
      const result = this.strategyContext.validateAction(sourcePosition, pos);
      if (!result.isValid) {
        logger.debug('Filtering out invalid position', { 
          position: pos, 
          reason: result.reason 
        });
        return false;
      }
      return true;
    });
    
    this.strategyContext.highlightValidPositions(validPositions, this.scene, {
      color: playerColor,
      opacity: GameConstants.HIGHLIGHT_OPACITY,
      particleEffect: particlesEnabled
    });

    this.currentAction = {
      type: actionType,
      isProcessing: false,
      validPositions,
      sourcePosition
    };

    logger.info('Action started', { 
      type: actionType,
      validPositions: validPositions.length,
      particles: particlesEnabled
    });
  }

  /**
   * Validates if a position is valid for the current action
   * @param targetPos Position to validate
   */
  public isValidActionPosition(targetPos: Position): boolean {
    if (!this.currentAction.sourcePosition) {
      logger.warn('No source position set for validation');
      return false;
    }

    const result = this.strategyContext.validateAction(
      this.currentAction.sourcePosition,
      targetPos
    );

    if (!result.isValid) {
      logger.warn('Invalid action position', { 
        reason: result.reason,
        targetPos 
      });
    }

    return result.isValid;
  }

  // Added method to explicitly clear highlights
  public clearHighlights(scene: Scene): void {
      if (!this.scene) {
        logger.warn('Cannot clear highlights: scene not set.');
        return;
      }
      this.strategyContext.clearHighlights(scene);
      logger.info('Highlights cleared explicitly via ActionManager.');
  }

  // Added method to end the current action and clear highlights
  public endCurrentAction(): void {
      this.clearAction(); // clearAction already handles highlight clearing and resetting state
      logger.info('Current action ended via ActionManager.');
  }
}

================
File: src/services/BoardStateManager.ts
================
import { gameConfig } from '../config/GameConfig';
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
export type ObjectType = 'ground' | 'cube' | 'player';

export interface BoardObject {
  type: ObjectType;
  height: number;  // y-coordinate of the top surface
  id?: string;     // for cubes and players
  color?: string;  // for players
}

export interface Position {
  x: number;
  y: number;
  z: number;
}

export interface BoardPosition {
  objects: BoardObject[];
}

export class BoardStateManager {
  private static instance: BoardStateManager;
  private boardState: Map<string, BoardPosition>;

  private constructor() {
    this.boardState = new Map();
    logger.info('Board state manager initialized');
  }

  public static getInstance(): BoardStateManager {
    if (!BoardStateManager.instance) {
      BoardStateManager.instance = new BoardStateManager();
    }
    return BoardStateManager.instance;
  }

  private getPositionKey(x: number, z: number): string {
    return `${x},${z}`;
  }

  public updatePosition(x: number, z: number, object: BoardObject): void {
    const key = this.getPositionKey(x, z);
    const currentPosition = this.boardState.get(key) || { objects: [] };
    
    // If it's a player, remove any existing player at this position
    if (object.type === 'player') {
      currentPosition.objects = currentPosition.objects.filter(obj => obj.type !== 'player');
    }
    
    // Add the new object, keeping the array sorted by height
    currentPosition.objects.push(object);
    currentPosition.objects.sort((a, b) => a.height - b.height);
    
    this.boardState.set(key, currentPosition);
    // logger.info('Position updated', { x, z, object, currentState: currentPosition });
  }

  public removeObject(x: number, z: number, id: string): void {
    const key = this.getPositionKey(x, z);
    const position = this.boardState.get(key);
    
    if (position) {
      position.objects = position.objects.filter(obj => obj.id !== id);
      if (position.objects.length === 0) {
        this.boardState.delete(key);
      } else {
        this.boardState.set(key, position);
      }
      logger.info('Object removed', { x, z, id });
    }
  }

  public getValidMoves(playerPos: Position): Position[] {
    const validMoves: Position[] = [];
    const directions = [
      { x: 0, z: 1 },   // North
      { x: 0, z: -1 },  // South
      { x: 1, z: 0 },   // East
      { x: -1, z: 0 }   // West
    ];

    const currentKey = this.getPositionKey(playerPos.x, playerPos.z);
    const currentPosition = this.boardState.get(currentKey);
    const currentHeight = this.getTopHeight(currentPosition);

    for (const dir of directions) {
      const targetX = playerPos.x + dir.x;
      const targetZ = playerPos.z + dir.z;
      const targetKey = this.getPositionKey(targetX, targetZ);
      const targetPosition = this.boardState.get(targetKey);

      if (this.isValidMove(currentHeight, targetPosition)) {
        const targetHeight = this.getTopHeight(targetPosition);
        validMoves.push({ x: targetX, y: targetHeight, z: targetZ });
      }
    }

    logger.info('Valid moves calculated', { 
      playerPos, 
      validMoves,
      currentHeight 
    });

    return validMoves;
  }

  private getTopHeight(position?: BoardPosition): number {
    if (!position || position.objects.length === 0) return 0;
    return position.objects[position.objects.length - 1].height;
  }

  private isValidMove(currentHeight: number, targetPosition?: BoardPosition): boolean {
    if (!targetPosition) return true; // Can move to empty space

    const config = gameConfig.getConfig();
    const targetHeight = this.getTopHeight(targetPosition);
    const heightDiff = targetHeight - currentHeight;

    // Check if target has a player
    const hasPlayer = targetPosition.objects.some(obj => obj.type === 'player');
    if (hasPlayer) return false;

    // Check height difference
    if (heightDiff > 0) {
      // Moving up
      return heightDiff <= config.movement.maxClimbHeight;
    } else if (heightDiff < 0) {
      // Moving down
      return config.movement.maxDescendHeight === 0 || 
             Math.abs(heightDiff) <= config.movement.maxDescendHeight;
    }

    return true; // Same height
  }

  public getObjectsAt(x: number, z: number): BoardObject[] {
    const position = this.boardState.get(this.getPositionKey(x, z));
    return position?.objects || [];
  }

  public getTopObject(x: number, z: number): BoardObject | undefined {
    const objects = this.getObjectsAt(x, z);
    return objects.length > 0 ? objects[objects.length - 1] : undefined;
  }

  public clear(): void {
    this.boardState.clear();
    logger.info('Board state cleared');
  }
}

export const boardState = BoardStateManager.getInstance();

================
File: src/services/gameLogic.ts
================
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();;
import { GameManager } from './GameManager';
import { GameConstants } from '../constants/GameConstants';

export class GameLogic {
  private static instance: GameLogic;
  private gameManager: GameManager;
  private stateMachine: any;
  private _stateMachineAttached: boolean;
  private _initialized: boolean;

  private constructor() {
    this.gameManager = GameManager.getInstance();
    this.stateMachine = null;
    this._stateMachineAttached = false;
    this._initialized = false;
    logger.info('GameLogic initialized');
  }

  public static getInstance(): GameLogic {
    if (!GameLogic.instance) {
      GameLogic.instance = new GameLogic();
    }
    return GameLogic.instance;
  }

  public setStateMachine(stateMachine: any): void {
    // Only attach if not already attached or if the interface has changed
    if (!this._stateMachineAttached || 
        !this.stateMachine || 
        this.stateMachine.getStateData !== stateMachine.getStateData) {
      this.stateMachine = stateMachine;
      this._stateMachineAttached = true;
      
      // If already initialized, update state machine with current state
      if (this._initialized) {
        const gameState = this.getGameState();
        if (this.stateMachine.updateStateData) {
          this.stateMachine.updateStateData({
            ...gameState,
            moveHistory: [],
            timestamp: Date.now()
          });
        }
      }
      
      logger.info('State machine attached to GameLogic', { 
        currentPlayer: this.getCurrentPlayer(),
        gamePhase: this.getGamePhase(),
        initialized: this._initialized
      });
    }
  }

  public initializeGame(): void {
    if (this._initialized) {
      logger.info('Game already initialized, skipping initialization');
      return;
    }

    // Initialize game state
    this.gameManager.initializeGame();
    
    // Get the current game state
    const gameState = this.getGameState();
    
    // Update state machine if attached
    if (this.stateMachine && this.stateMachine.updateStateData) {
      this.stateMachine.updateStateData({
        ...gameState,
        moveHistory: [],
        timestamp: Date.now()
      });
    }

    this._initialized = true;

    logger.info('Game initialization complete', {
      currentPlayer: gameState.currentPlayerId,
      gamePhase: gameState.gamePhase,
      players: gameState.players?.length || 0,
      cubes: Object.keys(gameState.cubes || {}).length
    });
  }

  public build(playerId: number, position: number[]): boolean {
    if (!this._initialized) {
      logger.warn('Game not initialized, cannot build');
      return false;
    }

    const result = this.gameManager.build(playerId, position);
    if (result && this.stateMachine && this.stateMachine.updateStateData) {
      const gameState = this.getGameState();
      this.stateMachine.updateStateData({
        ...gameState,
        moveHistory: [...(this.stateMachine.getStateData()?.moveHistory || []), {
          type: 'build',
          playerId,
          position,
          timestamp: Date.now()
        }]
      });
    }
    return result;
  }

  public move(playerId: number, position: number[]): boolean {
    if (!this._initialized) {
      logger.warn('Game not initialized, cannot move');
      return false;
    }

    const result = this.gameManager.move(playerId, position);
    if (result && this.stateMachine && this.stateMachine.updateStateData) {
      const gameState = this.getGameState();
      this.stateMachine.updateStateData({
        ...gameState,
        moveHistory: [...(this.stateMachine.getStateData()?.moveHistory || []), {
          type: 'move',
          playerId,
          position,
          timestamp: Date.now()
        }]
      });
    }
    return result;
  }

  public getGameState(): any {
    const state = this.gameManager.getGameState();
    // Ensure the state has all required fields
    return {
      ...state,
      currentPlayerId: state.currentPlayerId || this.getCurrentPlayer(),
      gamePhase: state.gamePhase || 'playing',
      players: state.players || [],
      cubes: state.cubes || {},
      logs: state.logs || []
    };
  }

  public getCurrentPlayer(): number | null {
    return this.gameManager.getCurrentPlayer();
  }

  public getGamePhase(): string {
    return this.gameManager.getGamePhase();
  }

  public endTurn(): void {
    if (!this._initialized) {
      logger.warn('Game not initialized, cannot end turn');
      return;
    }

    this.gameManager.endTurn();
    if (this.stateMachine && this.stateMachine.updateStateData) {
      const gameState = this.getGameState();
      this.stateMachine.updateStateData({
        ...gameState,
        moveHistory: [...(this.stateMachine.getStateData()?.moveHistory || []), {
          type: 'endTurn',
          playerId: this.getCurrentPlayer(),
          timestamp: Date.now()
        }]
      });
    }
  }
}

================
File: src/services/GameManager.ts
================
import { GameStateManager } from './GameStateManager';
import { ActionHandler } from './ActionHandler';
import { MagneticPhysics } from './physics';
import { GameConstants } from '../constants/GameConstants';
import { store } from '../store';
import { movePlayer, addCube as addCubeAction } from '../store/gameReducer';
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
export class GameManager {
  private static instance: GameManager;
  private stateManager: GameStateManager;
  private actionHandler: ActionHandler;
  private physics: MagneticPhysics;

  private constructor() {
    this.stateManager = GameStateManager.getInstance();
    this.actionHandler = ActionHandler.getInstance();
    this.physics = MagneticPhysics.getInstance();
    logger.info('GameManager initialized');
  }

  public static getInstance(): GameManager {
    if (!GameManager.instance) {
      GameManager.instance = new GameManager();
    }
    return GameManager.instance;
  }

  public initializeGame(): void {
    logger.info('Initializing game');

    // Clear previous state
    this.stateManager.clearState();

    // Initialize physics
    this.physics.init();

    // Set up initial game state
    this.stateManager.setGamePhase(GameConstants.STATE_PLAYING);
    this.stateManager.setCurrentPlayer(2); // Start with player 2 (Blue)

    // Dispatch initial state to Redux
    store.dispatch({
      type: 'game/initialize',
      payload: this.stateManager.toJSON()
    });

    logger.info('Game initialization complete');
  }

  public build(playerId: number, position: number[]): boolean {
    const success = this.actionHandler.build(playerId, position);
    if (success) {
      // Update Redux store
      store.dispatch(addCubeAction({
        id: `cube-${Date.now()}`,
        position,
        owner: playerId
      }));
    }
    return success;
  }

  public move(playerId: number, position: number[]): boolean {
    const success = this.actionHandler.move(playerId, position);
    if (success) {
      // Update Redux store
      store.dispatch(movePlayer({
        playerId,
        position
      }));
    }
    return success;
  }

  public getGameState(): any {
    return this.stateManager.toJSON();
  }

  public getCurrentPlayer(): number | null {
    return this.stateManager.getCurrentPlayer();
  }

  public getGamePhase(): string {
    return this.stateManager.getGamePhase();
  }

  public endTurn(): void {
    const currentPlayer = this.stateManager.getCurrentPlayer();
    if (currentPlayer === null) return;

    // Reset player actions
    const player = this.stateManager.getPlayer(currentPlayer);
    if (player) {
      player.canMove = true;
      player.canBuild = true;
      player.canRoll = true;
    }

    // Set next player
    const nextPlayer = (currentPlayer % 4) + 1;
    this.stateManager.setCurrentPlayer(nextPlayer);

    logger.info('Turn ended', {
      previousPlayer: currentPlayer,
      nextPlayer
    });
  }
}

================
File: src/services/GameStateManager.ts
================
import { Position } from './BoardStateManager';
import { GameConstants } from '../constants/GameConstants';
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
export interface Player {
  id: number;
  color: string;
  position: number[];
  powerCards: any[];
  magneticFieldStrength: number;
  canMove: boolean;
  canBuild: boolean;
  canRoll: boolean;
}

export interface Cube {
  id: string;
  position: number[];
  owner: number | null;
  size: number;
}

export class GameStateManager {
  private static instance: GameStateManager;
  private players: Map<number, Player>;
  private cubes: Map<string, Cube>;
  private currentPlayer: number | null;
  private gamePhase: string;

  private constructor() {
    this.players = new Map();
    this.cubes = new Map();
    this.currentPlayer = null;
    this.gamePhase = GameConstants.STATE_SETUP;
    logger.info('GameStateManager initialized');
  }

  public static getInstance(): GameStateManager {
    if (!GameStateManager.instance) {
      GameStateManager.instance = new GameStateManager();
    }
    return GameStateManager.instance;
  }

  public getPlayers(): Map<number, Player> {
    return this.players;
  }

  public getCubes(): Map<string, Cube> {
    return this.cubes;
  }

  public getCurrentPlayer(): number | null {
    return this.currentPlayer;
  }

  public setCurrentPlayer(playerId: number): void {
    this.currentPlayer = playerId;
    logger.info('Current player set', { playerId });
  }

  public getGamePhase(): string {
    return this.gamePhase;
  }

  public setGamePhase(phase: string): void {
    this.gamePhase = phase;
    logger.info('Game phase set', { phase });
  }

  public addPlayer(player: Player): void {
    this.players.set(player.id, player);
    logger.info('Player added', { playerId: player.id });
  }

  public removePlayer(playerId: number): void {
    this.players.delete(playerId);
    logger.info('Player removed', { playerId });
  }

  public addCube(cube: Cube): void {
    this.cubes.set(cube.id, cube);
    logger.info('Cube added', { cubeId: cube.id });
  }

  public removeCube(cubeId: string): void {
    this.cubes.delete(cubeId);
    logger.info('Cube removed', { cubeId });
  }

  public getPlayer(playerId: number): Player | undefined {
    return this.players.get(playerId);
  }

  public getCube(cubeId: string): Cube | undefined {
    return this.cubes.get(cubeId);
  }

  public clearState(): void {
    this.players.clear();
    this.cubes.clear();
    this.currentPlayer = null;
    this.gamePhase = GameConstants.STATE_SETUP;
    logger.info('Game state cleared');
  }

  public toJSON(): any {
    return {
      players: Array.from(this.players.values()),
      cubes: Array.from(this.cubes.values()),
      currentPlayer: this.currentPlayer,
      gamePhase: this.gamePhase
    };
  }
}

================
File: src/services/notifications.js
================
import { toast } from 'react-toastify'
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
import { isFeatureEnabled } from '../config/featureFlags'

// Queue for managing toast notifications
class ToastQueue {
  constructor() {
    this.queue = []
    this.activeToasts = new Set()
    this.MAX_ACTIVE_TOASTS = 5
    this.subscriptions = new Set()
  }

  add(toastConfig) {
    // Only show toasts if the feature is enabled
    if (!isFeatureEnabled('TOAST_NOTIFICATIONS')) {
      return
    }

    // If we have room for more toasts, show immediately
    if (this.activeToasts.size < this.MAX_ACTIVE_TOASTS) {
      this.showToast(toastConfig)
    } else {
      // Otherwise queue it
      this.queue.push(toastConfig)
    }
  }

  showToast({ level, message, context }) {
    const toastId = `${level}-${Date.now()}`
    this.activeToasts.add(toastId)

    toast[toastTypeMap[level]](
      context ? `${message}\n${JSON.stringify(context, null, 2)}` : message,
      {
        ...toastOptions,
        toastId,
        onClose: () => {
          this.activeToasts.delete(toastId)
          // When a toast closes, show the next one if queued
          if (this.queue.length > 0 && this.activeToasts.size < this.MAX_ACTIVE_TOASTS) {
            this.showToast(this.queue.shift())
          }
        }
      }
    )
  }

  cleanup() {
    // Clear all active toasts
    this.activeToasts.forEach(toastId => {
      toast.dismiss(toastId)
    })
    this.activeToasts.clear()
    this.queue = []

    // Unsubscribe from all log levels
    this.subscriptions.forEach(({ level, callback }) => {
      logger.unsubscribe(level, callback)
    })
    this.subscriptions.clear()
  }
}

// Create a single instance of ToastQueue
const toastQueue = new ToastQueue()

// Configure toast options for different log levels
const toastOptions = {
  position: "top-right",
  autoClose: 3000,
  hideProgressBar: false,
  closeOnClick: true,
  pauseOnHover: true,
  draggable: true,
  progress: undefined
}

// Map log levels to toast types
const toastTypeMap = {
  debug: 'info',
  info: 'info',
  warn: 'warning',
  error: 'error'
}

// Initialize notification service
export const initNotifications = () => {
  // Clean up any existing subscriptions first
  toastQueue.cleanup()

  // Only initialize if the feature is enabled
  if (!isFeatureEnabled('TOAST_NOTIFICATIONS')) {
    return () => {}
  }

  // Subscribe to all log levels
  Object.keys(toastTypeMap).forEach(level => {
    const callback = (level, message, context) => {
      // Don't show toasts for debug messages in production
      if (level === 'debug' && process.env.NODE_ENV === 'production') {
        return
      }

      // Add to queue or show immediately if space available
      toastQueue.add({ level, message, context })
    }

    logger.subscribe(level, callback)
    toastQueue.subscriptions.add({ level, callback })
  })

  // Return cleanup function
  return () => {
    toastQueue.cleanup()
  }
}

// Export cleanup function for direct usage
export const cleanupNotifications = () => {
  toastQueue.cleanup()
}

================
File: src/services/physics.js
================
import { Vector3 } from 'three'
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();
import { Singleton } from '../utils/Singleton'

const MIN_DISTANCE = 0.5 // Minimum distance for collision detection
const MAX_HEIGHT = 5    // Maximum build height

export class MagneticPhysics {
  static getInstance() {
    return Singleton.getInstance(MagneticPhysics)
  }

  constructor() {
    logger.info('Initializing MagneticPhysics')
    this.cubes = new Map()
    this.disposed = false
    this.initialized = false
  }

  init() {
    if (this.initialized) return
    logger.info('Initializing physics system')
    this.initialized = true
    this.disposed = false
  }

  addCube(cubeId, position) {
    if (this.disposed || !this.initialized) return

    const newPosition = new Vector3(...position)
    
    // Normalize to grid
    newPosition.x = Math.round(newPosition.x * 2) / 2
    newPosition.y = Math.round(newPosition.y)
    newPosition.z = Math.round(newPosition.z * 2) / 2
    
    this.cubes.set(cubeId, newPosition)
    logger.debug('Added cube to physics', { cubeId, position: newPosition })
  }

  removeCube(cubeId) {
    if (this.disposed || !this.initialized) return
    this.cubes.delete(cubeId)
    logger.debug('Removed cube from physics', { cubeId })
  }

  getCubePosition(cubeId) {
    if (this.disposed || !this.initialized) return null

    const position = this.cubes.get(cubeId)
    if (!position) {
      logger.warn('Attempted to get position of non-existent cube', { cubeId })
      return null
    }
    return position.toArray()
  }

  isValidPlacement(position, playerPosition) {
    if (this.disposed || !this.initialized) {
      logger.warn('Physics system not ready');
      return false;
    }

    const pos = new Vector3(...position)
    const playerPos = new Vector3(...playerPosition)
    
    // Normalize to grid
    pos.x = Math.round(pos.x * 2) / 2
    pos.y = Math.round(pos.y)
    pos.z = Math.round(pos.z * 2) / 2

    logger.debug('Checking build position', { 
      normalized: pos.toArray(),
      original: position,
      playerPosition: playerPos.toArray()
    });

    // 1. Check height limit
    if (pos.y > MAX_HEIGHT) {
      logger.warn('Build position exceeds maximum height', { 
        height: pos.y,
        maxHeight: MAX_HEIGHT 
      });
      return false;
    }

    // 2. Check for exact position collision
    for (const [cubeId, cubePos] of this.cubes) {
      if (Math.abs(pos.x - cubePos.x) < MIN_DISTANCE &&
          Math.abs(pos.y - cubePos.y) < MIN_DISTANCE &&
          Math.abs(pos.z - cubePos.z) < MIN_DISTANCE) {
        logger.warn('Position already occupied', { 
          position: pos.toArray(),
          existingCube: cubeId 
        });
        return false;
      }
    }

    // 4. Check for support (must have cube below except at y=0)
    if (pos.y > 0) {
      let hasSupport = false;
      for (const [cubeId, cubePos] of this.cubes) {
        // Check for cube directly below
        if (Math.abs(pos.x - cubePos.x) < MIN_DISTANCE &&
            Math.abs(pos.z - cubePos.z) < MIN_DISTANCE &&
            Math.abs(pos.y - (cubePos.y + 1)) < MIN_DISTANCE) {
          hasSupport = true;
          break;
        }
      }
      if (!hasSupport) {
        logger.warn('No supporting cube found below position', { 
          position: pos.toArray() 
        });
        return false;
      }
    }

    logger.info('Position valid for build', { 
      position: pos.toArray(),
      playerPosition: playerPos.toArray()
    });
    return true;
  }

  dispose() {
    if (this.disposed) return

    logger.info('Disposing physics system')
    this.disposed = true
    this.initialized = false
    this.cubes.clear()
  }
}

================
File: src/store/middleware/actionValidation.js
================
import { GameLogic } from '../../services/GameLogic'
import { UniversalLogger } from '../../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();

const game = new GameLogic()

export const actionValidation = () => (next) => (action) => {
  logger.debug('Validating action', { type: action.type, payload: action.payload })

  // Validate actions before they are dispatched
  switch (action.type) {
    case 'game/build':
      const isValidPlacement = game.physics.isValidPlacement(action.payload)
      if (!isValidPlacement) {
        logger.warn('Invalid build action', {
          position: action.payload,
          reason: 'Invalid placement position'
        })
        return
      }
      logger.info('Build action validated', { position: action.payload })
      break

    case 'game/move':
      const currentPos = game.getCurrentPlayerPosition()
      const isValidMove = game.isValidMove(currentPos, action.payload)
      if (!isValidMove) {
        logger.warn('Invalid move action', {
          from: currentPos,
          to: action.payload,
          reason: 'Invalid move position'
        })
        return
      }
      logger.info('Move action validated', {
        from: currentPos,
        to: action.payload
      })
      break

    case 'game/roll':
      logger.info('Roll action validated')
      break

    case 'game/endTurn':
      logger.info('End turn action validated')
      break

    default:
      logger.debug('Action type not requiring validation', { type: action.type })
  }

  logger.debug('Action passed validation, dispatching', { type: action.type })
  next(action)
}

================
File: src/store/reducers/gameReducer.js
================
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();

const initialState = {
  players: [],
  currentPlayer: null,
  cubes: {},
  selectedPowerCard: null,
  logs: [],
  gameState: 'initializing'
}

const gameReducer = (state = initialState, action) => {
  logger.debug('Game reducer action', { action })

  switch (action.type) {
    case 'game/initialize':
      return {
        ...state,
        players: action.payload.players,
        currentPlayer: action.payload.players[0],
        gameState: 'playing',
        logs: []
      }

    case 'game/build':
      return {
        ...state,
        cubes: {
          ...state.cubes,
          [action.payload.id]: action.payload
        },
        logs: [
          ...state.logs,
          {
            timestamp: new Date().toISOString(),
            level: 'info',
            message: `Player ${state.currentPlayer.id} built cube at ${action.payload.position.join(', ')}`,
            context: action.payload
          }
        ]
      }

    case 'game/move':
      return {
        ...state,
        players: state.players.map(player =>
          player.id === state.currentPlayer.id
            ? { ...player, position: action.payload }
            : player
        ),
        logs: [
          ...state.logs,
          {
            timestamp: new Date().toISOString(),
            level: 'info',
            message: `Player ${state.currentPlayer.id} moved to ${action.payload.join(', ')}`,
            context: action.payload
          }
        ]
      }

    case 'game/roll':
      return {
        ...state,
        logs: [
          ...state.logs,
          {
            timestamp: new Date().toISOString(),
            level: 'info',
            message: `Player ${state.currentPlayer.id} rolled ${action.payload}`,
            context: action.payload
          }
        ]
      }

    case 'game/endTurn':
      const currentPlayerIndex = state.players.findIndex(p => p.id === state.currentPlayer.id)
      const nextPlayerIndex = (currentPlayerIndex + 1) % state.players.length
      const nextPlayer = state.players[nextPlayerIndex]

      return {
        ...state,
        currentPlayer: nextPlayer,
        logs: [
          ...state.logs,
          {
            timestamp: new Date().toISOString(),
            level: 'info',
            message: `Turn ended. Next player: ${nextPlayer.id}`,
            context: { nextPlayer: nextPlayer.id }
          }
        ]
      }

    case 'game/usePowerCard':
      return {
        ...state,
        selectedPowerCard: null,
        logs: [
          ...state.logs,
          {
            timestamp: new Date().toISOString(),
            level: 'info',
            message: `Player ${state.currentPlayer.id} used power card on cube ${action.payload.target}`,
            context: action.payload
          }
        ]
      }

    default:
      return state
  }
}

export default gameReducer

================
File: src/store/gameReducer.js
================
import { createSlice } from '@reduxjs/toolkit'
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();

const PLAYER_COLORS = {
  1: '#f44336', // Red
  2: '#2196F3', // Blue
  3: '#4CAF50', // Green
  4: '#FFC107'  // Yellow
}

// Board layout (4x4 grid):
// pccp  where p=player, c=cube
// cccc  Each unit is 1x1
// cccc  No gaps between elements
// pccp
const INITIAL_POSITIONS = {
  1: [-1.5, 0, -1.5], // Red - Bottom Left
  2: [1.5, 0, -1.5],  // Blue - Bottom Right
  3: [-1.5, 0, 1.5],  // Green - Top Left
  4: [1.5, 0, 1.5]    // Yellow - Top Right
}

// Define power cards based on game rules
const POWER_CARDS = {
  ACCELERATE: { id: 'accelerate', name: 'Accelerate', description: 'Take an extra turn after this one', type: 'movement' },
  ARMAGEDDON: { id: 'armageddon', name: 'Armageddon', description: 'Remove 1 cube under any number of players', type: 'attack' },
  BARRIER: { id: 'barrier', name: 'Barrier', description: 'Negate wind or a power that would affect you', type: 'defense' },
  ECHO: { id: 'echo', name: 'Echo', description: 'Use one of your other powers once more', type: 'utility' },
  FREEZE: { id: 'freeze', name: 'Freeze', description: 'Each other player cannot perform their move action next turn', type: 'control' },
  GAMBLE: { id: 'gamble', name: 'Gamble', description: 'Perform the roll action twice this turn', type: 'utility' },
  IGNITE: { id: 'ignite', name: 'Ignite', description: 'Remove 1 or 2 cubes under any player', type: 'attack' },
  KICK: { id: 'kick', name: 'Kick', description: 'Move an adjacent player to any adjacent space', type: 'attack' },
  LEVITATE: { id: 'levitate', name: 'Levitate', description: 'Build directly under yourself', type: 'movement' },
  LIMITLESS: { id: 'limitless', name: 'Limitless', description: 'Move any number of times this turn', type: 'movement' },
  MASTERY: { id: 'mastery', name: 'Mastery', description: 'Perform a grapple action', type: 'utility' },
  REVIVE: { id: 'revive', name: 'Revive', description: 'Place yourself on any unoccupied space below level 3', type: 'movement' },
  ROAR: { id: 'roar', name: 'Roar', description: 'Adjacent players cannot move or grapple next turn', type: 'control' },
  STEAL: { id: 'steal', name: 'Steal', description: 'Move a cube from under another player to under yourself', type: 'attack' },
  TELEKINESIS: { id: 'telekinesis', name: 'Telekinesis', description: 'Move 2 unoccupied cubes to any valid position', type: 'utility' },
  TIME_STOP: { id: 'time_stop', name: 'Time Stop', description: 'End your turn without performing another action', type: 'utility' }
}

// Assign initial power cards to players
const INITIAL_POWER_CARDS = {
  1: [POWER_CARDS.IGNITE, POWER_CARDS.BARRIER],     // Red - Aggressive start
  2: [POWER_CARDS.FREEZE, POWER_CARDS.TELEKINESIS], // Blue - Control oriented
  3: [POWER_CARDS.LIMITLESS, POWER_CARDS.STEAL],    // Green - Mobile and tricky
  4: [POWER_CARDS.ROAR, POWER_CARDS.LEVITATE]       // Yellow - Defensive setup
}

// Create initial cube positions based on the board layout
const createInitialCubes = () => {
  const cubes = {}
  let cubeId = 1

  // Create the 4x4 grid of cubes
  // Using -0.5 to 0.5 range for inner cubes to make them adjacent
  for (let z = -1.5; z <= 1.5; z++) {
    for (let x = -1.5; x <= 1.5; x++) {
      // Skip positions where players start (corners)
      if ((Math.abs(x) === 1.5 && Math.abs(z) === 1.5)) {
        continue
      }
      
      cubes[`cube-${cubeId}`] = {
        id: `cube-${cubeId}`,
        position: [x, 0, z],
        owner: null,
        size: 1 // Adding explicit size for reference
      }
      cubeId++
    }
  }

  return cubes
}

// Add new action types for logging and action selection
const addGameLog = (state, message) => {
  const timestamp = new Date().toLocaleTimeString()
  state.logs.unshift(`[${timestamp}] ${message}`)
  // Keep only the last 50 logs
  if (state.logs.length > 50) {
    state.logs.pop()
  }
}

const gameSlice = createSlice({
  name: 'game',
  initialState: {
    players: [],
    currentPlayer: null,
    cubes: {},
    logs: [],
    gameState: 'setup',
    turnNumber: 0,
    selectedAction: null
  },
  reducers: {
    initializeGame: (state, action) => {
      const { players, cubes, currentPlayerId, gamePhase, turnNumber } = action.payload;
      logger.info('Reducer: Setting initial state from GameLogic', { payload: action.payload });

      state.players = players; // Assume payload.players is already the correct array
      state.cubes = cubes;     // Assume payload.cubes is already the correct object
      state.currentPlayer = players.find(p => p.id === currentPlayerId) || null;
      state.gameState = gamePhase;
      state.turnNumber = turnNumber;
      state.logs = []; // Clear logs on new init
      state.selectedAction = null;

      if (state.gameState === 'playing') {
        addGameLog(state, "Game started - Player " + (state.currentPlayer?.id || '?') + "'s turn");
      }
      logger.info('Redux state updated from GameLogic', { 
        players: state.players.length,
        currentPlayer: state.currentPlayer?.id,
        cubes: Object.keys(state.cubes).length,
        gameState: state.gameState
      });

      // Log the entire state after initialization
      console.log("[initializeGame] Initial state:", JSON.stringify(state, null, 2));
    },
    
    // Added reducer for moving a player
    movePlayer: (state, action) => {
      const { playerId, newPosition } = action.payload;
      const playerIndex = state.players.findIndex(p => p.id === playerId);
      
      if (playerIndex !== -1) {
        // Apply mutations to the draft player within the array
        state.players[playerIndex].position = newPosition;
        state.players[playerIndex].canMove = false; 
        addGameLog(state, `Player ${playerId} moved to [${newPosition.join(', ')}]`);

        // If this was the current player, update the state.currentPlayer reference
        // by explicitly re-assigning from the (potentially) new array reference
        if (state.currentPlayer && state.currentPlayer.id === playerId) {
           state.currentPlayer = state.players[playerIndex]; 
           // Explicitly set canBuild and canRoll to true
           state.currentPlayer.canBuild = true;
           state.currentPlayer.canRoll = true;
           // Log the entire state after updating currentPlayer
           console.log("[movePlayer] State after updating currentPlayer:", JSON.stringify(state, null, 2));
        }
      } else {
        logger.error(`Reducer movePlayer: Player ${playerId} not found.`);
      }
    },

    // Added reducer for adding a cube
    addCube: (state, action) => {
      const { id, position, owner = null } = action.payload; // Use payload directly
      if (!state.cubes[id]) { 
        state.cubes[id] = { id, position, owner }; // Set owner if provided
        addGameLog(state, `Cube ${id} added at [${position.join(', ')}]`);
      } else {
         logger.warn(`Reducer addCube: Cube ${id} already exists.`);
      }
    },

    selectAction: (state, action) => {
      const { actionType } = action.payload
      state.selectedAction = actionType
      addGameLog(state, `${state.currentPlayer.id === 2 ? 'Blue' : 'Red'} player selected ${actionType}`)
    },

    nextTurn: (state) => {
      const currentPlayerIndex = state.players.findIndex(p => p.id === state.currentPlayer.id);
      const nextPlayerIndex = (currentPlayerIndex + 1) % state.players.length;
      const nextPlayer = state.players[nextPlayerIndex]; // Get the next player object

      // Reset action flags for the *new* current player
      nextPlayer.canMove = true;
      nextPlayer.canBuild = true;
      nextPlayer.canRoll = true;

      // Update the currentPlayer reference to the next player
      state.currentPlayer = nextPlayer; // Assign the reference to the new current player
      state.turnNumber++;
      state.selectedAction = null;

      const playerColors = {
        1: 'Red',
        2: 'Blue',
        3: 'Green',
        4: 'Yellow'
      };

      addGameLog(state, `Turn ${state.turnNumber} - ${playerColors[state.currentPlayer.id]}'s turn`);

      // Log the entire state after updating currentPlayer
      console.log("[nextTurn] State after updating currentPlayer:", JSON.stringify(state, null, 2));
    },

    updateGameState: (state, action) => {
      const { gameState, stateData } = action.payload
      let hasChanges = false;
      
      if (gameState && gameState !== state.gameState) {
        state.gameState = gameState;
        hasChanges = true;
      }
      
      if (stateData) {
        // Update players if provided and changed
        if (stateData.players) {
          const newPlayers = stateData.players.map(player => ({
            ...player,
            id: parseInt(player.id),
            position: Array.isArray(player.position) ? player.position : [player.position.x, player.position.y, player.position.z]
          }));

          // Only update if players have changed
          if (JSON.stringify(newPlayers) !== JSON.stringify(state.players)) {
            state.players = newPlayers;
            hasChanges = true;
          }
        }
        
        // Update current player if provided and changed
        if (stateData.currentPlayerId) {
          const newCurrentPlayer = state.players.find(p => p.id.toString() === stateData.currentPlayerId);
          if (newCurrentPlayer && (!state.currentPlayer || state.currentPlayer.id !== newCurrentPlayer.id)) {
            state.currentPlayer = newCurrentPlayer;
            hasChanges = true;
          }
        }
        
        // Update board state if provided and changed
        if (stateData.board) {
          const newCubes = stateData.board.reduce((acc, cube) => {
            acc[cube.id] = {
              ...cube,
              position: Array.isArray(cube.position) ? cube.position : [cube.position.x, cube.position.y, cube.position.z]
            }
            return acc;
          }, {});

          // Only update if cubes have changed
          if (JSON.stringify(newCubes) !== JSON.stringify(state.cubes)) {
            state.cubes = newCubes;
            hasChanges = true;
          }
        }
      }

      if (hasChanges) {
        logger.info('Game state updated', { 
          newGameState: gameState,
          stateDataUpdated: stateData ? Object.keys(stateData) : []
        });
      } else {
        logger.debug('No changes in game state update');
      }
    }
  }
})

export const { 
  initializeGame, 
  movePlayer,
  addCube,
  selectAction, 
  nextTurn,
  updateGameState 
} = gameSlice.actions

export default gameSlice.reducer

================
File: src/store/gameSlice.js
================
import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  currentPlayer: 1,
  players: [
    { id: 1, position: [0, 1, 0], color: '#ff0000' },
    { id: 2, position: [1, 1, 0], color: '#00ff00' },
    { id: 3, position: [0, 1, 1], color: '#0000ff' },
    { id: 4, position: [1, 1, 1], color: '#ffff00' }
  ],
  cubes: [
    { position: [0, 0, 0], color: '#ffffff' },
    { position: [1, 0, 0], color: '#ffffff' },
    { position: [0, 0, 1], color: '#ffffff' }
  ],
  powerCards: [],
  gamePhase: 'setup', // setup, playing, ended
  lastAction: null,
  selectedAction: null // build, move, roll, null
}

const gameSlice = createSlice({
  name: 'game',
  initialState,
  reducers: {
    setCurrentPlayer: (state, action) => {
      state.currentPlayer = action.payload
    },
    movePlayer: (state, action) => {
      const { playerId, newPosition } = action.payload
      const player = state.players.find(p => p.id === playerId)
      if (player) {
        player.position = newPosition
      }
    },
    addCube: (state, action) => {
      state.cubes.push(action.payload)
    },
    setGamePhase: (state, action) => {
      state.gamePhase = action.payload
    },
    setLastAction: (state, action) => {
      state.lastAction = action.payload
    },
    setSelectedAction: (state, action) => {
      state.selectedAction = action.payload
    },
    build: (state, action) => {
      state.cubes.push({
        position: action.payload,
        color: '#ffffff'
      })
      state.lastAction = 'build'
    },
    move: (state, action) => {
      const { playerId, position } = action.payload
      const player = state.players.find(p => p.id === playerId)
      if (player) {
        player.position = position
      }
      state.lastAction = 'move'
    },
    roll: (state) => {
      state.lastAction = 'roll'
    },
    endTurn: (state) => {
      state.currentPlayer = (state.currentPlayer % state.players.length) + 1
      state.selectedAction = null
    }
  }
})

export const {
  setCurrentPlayer,
  movePlayer,
  addCube,
  setGamePhase,
  setLastAction,
  setSelectedAction,
  build,
  move,
  roll,
  endTurn
} = gameSlice.actions

export default gameSlice.reducer

================
File: src/store/index.js
================
import { configureStore } from '@reduxjs/toolkit'
import gameReducer from './gameReducer'
import { actionValidation } from './middleware/actionValidation'
import { UniversalLogger } from '../utils/UniversalLogger'
const logger = UniversalLogger.getInstance();

export const createStore = () => {
  logger.info('Configuring Redux store')
  
  return configureStore({
    reducer: {
      game: gameReducer
    },
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware().concat(actionValidation),
    devTools: process.env.NODE_ENV !== 'production'
  })
}

// Create and export the store instance
export const store = createStore()

export default store

================
File: src/utils/Singleton.js
================
/**
 * Base Singleton class to handle instance management
 * @template T
 */
export class Singleton {
  static #instances = new Map()
  static #locks = new Map()

  /**
   * Get the singleton instance of a class
   * @template T
   * @param {new () => T} ClassConstructor - The class constructor
   * @returns {T} The singleton instance
   */
  static getInstance(ClassConstructor) {
    // Check if we're already creating an instance (lock check)
    if (this.#locks.get(ClassConstructor.name)) {
      throw new Error(`Recursive getInstance() call for ${ClassConstructor.name}`)
    }

    // Set lock while we create the instance
    this.#locks.set(ClassConstructor.name, true)

    try {
      // Get or create instance
      let instance = this.#instances.get(ClassConstructor.name)
      if (!instance) {
        instance = new ClassConstructor()
        this.#instances.set(ClassConstructor.name, instance)
      }
      return instance
    } finally {
      // Always remove the lock
      this.#locks.delete(ClassConstructor.name)
    }
  }

  /**
   * Clear all instances (useful for testing)
   */
  static clearInstances() {
    this.#instances.clear()
    this.#locks.clear()
  }
}

================
File: src/utils/UniversalLogger.ts
================
export class UniversalLogger {
  private static instance: UniversalLogger;
  private constructor() {}

  public static getInstance(): UniversalLogger {
    if (!UniversalLogger.instance) {
      UniversalLogger.instance = new UniversalLogger();
    }
    return UniversalLogger.instance;
  }

  private getCallerInfo(): { className: string; methodName: string; lineNumber: string } | null {
    const stack = new Error().stack;
    if (!stack) return null;

    const stackLines = stack.split('\n');
    // Skip the first line (Error) and look for the first non-logger caller
    for (let i = 2; i < stackLines.length; i++) {
      const line = stackLines[i];
      // Skip lines containing UniversalLogger
      if (line.includes('UniversalLogger')) continue;
      
      // Try different patterns to match various caller formats
      const patterns = [
        // Class.method format
        /at\s+(\w+)(?:\.(\w+))?\s+\(.*:(\d+):\d+\)/,
        // React component format
        /at\s+(\w+)\s+\(.*:(\d+):\d+\)/,
        // Anonymous function format
        /at\s+<(\w+)>\s+\(.*:(\d+):\d+\)/,
        // Function name format
        /at\s+(\w+)\s+\(.*:(\d+):\d+\)/,
        // Arrow function format
        /at\s+\(.*\)\s+\(.*:(\d+):\d+\)/
      ];

      for (const pattern of patterns) {
        const match = line.match(pattern);
        if (match) {
          const [, className, methodName, lineNumber] = match;
          // For React components and anonymous functions, className will be the function name
          return {
            className: className || 'Anonymous',
            methodName: methodName || '',
            lineNumber: lineNumber || '0'
          };
        }
      }
    }
    return null;
  }

  private formatCallerInfo(callerInfo: { className: string; methodName: string; lineNumber: string }): string {
    const { className, methodName, lineNumber } = callerInfo;
    const formattedMethod = methodName ? `.${methodName}` : '';
    return `[${className}${formattedMethod}:${lineNumber}]`;
  }

  public log(...args: any[]): void {
    const callerInfo = this.getCallerInfo();
    
    // Format the message and additional parameters
    const formattedArgs = args.map(arg => {
      if (typeof arg === 'object' && arg !== null) {
        try {
          return JSON.stringify(arg, null, 2);
        } catch (e) {
          return String(arg);
        }
      }
      return String(arg);
    }).join(' ');

    if (callerInfo) {
      console.log(this.formatCallerInfo(callerInfo), formattedArgs);
    } else {
      console.log(`[Unknown]`, formattedArgs);
    }
  }

  public info(...args: any[]): void {
    this.log('INFO:', ...args);
  }

  public warn(...args: any[]): void {
    this.log('WARN:', ...args);
  }

  public error(...args: any[]): void {
    this.log('ERROR:', ...args);
  }

  public debug(...args: any[]): void {
    this.log('DEBUG:', ...args);
  }
}

================
File: src/App.jsx
================
import React, { useEffect, Suspense } from 'react'
import { Canvas } from '@react-three/fiber'
import Scene from './components/three/Scene'
import { GameProvider } from './context/GameContext'
import GameUI from './components/ui/GameUI'
import styles from './App.module.css'
import { Provider } from 'react-redux'
import { store } from './store'
import { ToastContainer } from 'react-toastify'
import { initNotifications, cleanupNotifications } from './services/notifications'
import { useFeature } from './config/featureFlags'
import 'react-toastify/dist/ReactToastify.css'

function ThreeCanvas() {
  return (
    <Canvas
      shadows
      camera={{
        position: [15, 15, 15],
        fov: 50
      }}
    >
      <Suspense fallback={null}>
        <Scene />
      </Suspense>
    </Canvas>
  )
}

const AppContent = () => {
  const showToasts = useFeature('TOAST_NOTIFICATIONS')

  useEffect(() => {
    // Initialize notifications and store cleanup function
    const cleanup = initNotifications()

    // Clean up notifications when component unmounts
    return () => {
      cleanup()
      cleanupNotifications()
    }
  }, [])

  return (
    <div className={styles.app}>
      <div className={styles.canvasContainer}>
        <ThreeCanvas />
      </div>
      <GameUI />
      {showToasts && (
        <ToastContainer 
          theme="dark"
          position="top-right"
          autoClose={3000}
          hideProgressBar={false}
          newestOnTop={true}
          closeOnClick
          rtl={false}
          pauseOnFocusLoss
          draggable
          pauseOnHover
          style={{
            width: '400px',
            maxHeight: '80vh'
          }}
        />
      )}
    </div>
  )
}

function App() {
  return (
    <Provider store={store}>
      <GameProvider>
        <AppContent />
      </GameProvider>
    </Provider>
  )
}

export default App

================
File: src/App.module.css
================
.app {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  background: #000;
}

.canvasContainer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

.canvasContainer canvas {
  width: 100% !important;
  height: 100% !important;
}

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #000;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

#root {
  width: 100%;
  height: 100%;
  position: relative;
}

/* App styles */
.app {
  width: 100vw;
  height: 100vh;
  position: relative;
  background: #000;
  color: #fff;
  overflow: hidden;
}

.canvas-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

.ui-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 2;
}

.top-right {
  position: absolute;
  top: 20px;
  right: 20px;
  pointer-events: auto;
}

.bottom-left {
  position: absolute;
  bottom: 20px;
  left: 20px;
  pointer-events: auto;
}

.bottom-right {
  position: absolute;
  bottom: 20px;
  right: 20px;
  pointer-events: auto;
}

/* Remove default button styles */
button {
  border: none;
  background: none;
  font: inherit;
  cursor: pointer;
  padding: 0;
  color: inherit;
}

/* Ensure canvas takes full space */
canvas {
  width: 100% !important;
  height: 100% !important;
  display: block;
}

================
File: src/index.jsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import { Provider } from 'react-redux'
import { store } from './store'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
)

================
File: src/main.jsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import { Provider } from 'react-redux'
import { store } from './store'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
)



================================================================
End of Codebase
================================================================
